# ~/.bashrc.config

#------------------------------------------------------------------------------#
# Prompt
#------------------------------------------------------------------------------#

PROMPT_COMMAND='__set-prompt; __dump_history'
__set-prompt() {
  # Exit code of previous command (must be first statement)
  local exit_code=$?
  # Different colours for root and non-root users
  if [[ "$USER" = root ]]; then
    local colour=$(c red b)
    local user="root|"
  else
    local colour=$(c green b)
  fi
  # Include OS name and version on Linux
  if is-linux; then
    local os="$(os)|"
  fi
  # Prompt
  PS1="\[$colour\]$$|$os$user\w\$ \[$(c)\]"
  # Prepend exit code of previous command if it was non-zero
  if [[ "$exit_code" -ne 0 ]]; then
    PS1="\[$(c red b)\]$exit_code|$(c)$PS1"
  fi
}

# Append the last command to the $HISTFILE history file (for aggregating the
# history of all active shells)
# TODO: emulate HISTCONTROL=ignoredups by omitting writing a command to the
# history file if it's equal to the lastly written command.
__dump_history() {
  history -a
}


if is-linux; then

  # LS_COLORS (GNU-specific)
  # Fields:
  #   di=dir, ln=symlink, so=socket, pi=pipe, ex=executable, bd=block special,
  #   cd=char special, su=executble with setuid, sg=executable with setgid,
  #   tw=other-writable dir w. sticky bit, ow=other-writable dir wo. sticky bit
  # Colours:
  #   ANSI colour codes
  # Documentation:
  #   'man ls', 'man dircolors', 'dircolors'
  export LS_COLORS="di=1;36:ln=1;35:so=0:pi=0:ex=1;32:bd=0:cd=0:su=1;32:sg=1;32:tw=1;36:ow=1;36"

elif is-mac; then

  # LSCOLORS (BSD-specific)
  # Positions:
  #   1=dir, 2=symlink, 3=socket, 4=pipe, 5=executable, 6=block special,
  #   7=char special, 8=executable with setuid, 9=executable with setgid,
  #   10=other-writable dir w. sticky bit, 11=other-writable dir wo. sticky bit
  # Colours (lower-case means normal, upper-case means bold):
  #   a=black, b=red, c=green, d=yellow, e=blue, f=magenta, g=cyan, h=white,
  #   x=default
  # Format:
  #   <foreground><background>...
  # Example:
  #   Gx: bold cyan foreground and default background
  # Documentation:
  #   man ls (search for 'LSCOLORS')
  export LSCOLORS=GxFxHxHxCxHxHxCxCxGxGx
  export CLICOLOR=1

  # System
  export LANG=en_US.UTF-8
  export LC_ALL=en_US.UTF-8
  export TERM=xterm-256color # Works across multiple macOS systems and terminals
  # Increase history size (default 500)
  export HISTSIZE=5000
  export HISTFILESIZE=5000


  # Misc
  export d=~/Desktop
  export fonts_user=~/Library/Fonts
  export fonts_local=/Library/Fonts
  export fonts_system=/System/Library/Fonts
  #alias chrome="/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome"
fi

# EDITOR
if is-installed nvim; then
  export EDITOR=nvim
elif is-installed vim; then
  export EDITOR=vim
else
  unset EDITOR
fi


#------------------------------------------------------------------------------#
# Configure Readline
# https://www.gnu.org/software/bash/manual/html_node/Command-Line-Editing.html
#------------------------------------------------------------------------------#
bind 'set skip-completed-text on'

# Enable/disable vi line-editing mode (default is emacs)
vi-mode-on() {
  bind 'set editing-mode vi'  # Equivalen to set -o vi
  bind 'set show-mode-in-prompt on'
  bind 'set vi-ins-mode-string \1\033[1;32m@|\033[m\2'
  bind 'set vi-cmd-mode-string \1\033[1;42;37m@\033[;1;32m|\033[m\2'
  bind '"\C-k": vi-movement-mode'
}
vi-mode-off() {
  bind 'set editing-mode emacs'  # Equivalen to set +o vi
  bind 'set show-mode-in-prompt off'
}


#------------------------------------------------------------------------------#
# bash-completion
#------------------------------------------------------------------------------#

if is-mac ; then
  source $(brew --prefix)/etc/profile.d/bash_completion.sh
  # Homebrew formulas drop completion scripts here
  for f in $(brew --prefix)/etc/bash_completion.d/*; do
    source "$f"
  done
fi

# Only execute if bash-completion isn't activated yet
if is-linux && ! type _init_completion &>/dev/null; then
  # Code from /etc/bash.bashrc which by default is outcommented
  if [[ -f /usr/share/bash-completion/bash_completion ]]; then
    . /usr/share/bash-completion/bash_completion
  elif [[ -f /etc/bash_completion ]]; then
    . /etc/bash_completion
  fi
fi

#------------------------------------------------------------------------------#
# complete-alias (https://github.com/cykerway/complete-alias)
#------------------------------------------------------------------------------#

source ~/.complete_alias


# Make Bash resolve the word after 'sudo' as an alias [1,2], which makes it
# possible to execute aliases with sudo. Note that the replacement is done by
# the shell before invoking sudo and it works only with aliases, not with Bash
# functions (sudo itself works only with executables, it doesn't resolve aliases
# or shell functions, nor does it source .bashrc or .bash_profile). For full
# access to the environment, start an interactive shell with 'sudo -s' which
# in turn sources the .bashrc file found in $HOME.
# [1] https://linuxhandbook.com/run-alias-as-sudo/
# [2] https://www.gnu.org/software/bash/manual/bash.html#Aliases
alias sudo='sudo '

