# ~/.bashrc.lib
#
# Shell function library. All functions starting with a single underscore are
# intended to be used by other .bashrc.* files.
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
#= Function helpers
#------------------------------------------------------------------------------#

# If no arguments are provided, print stdin, else print the arguments.
# Usage:
#   _get-input [<args>...]
# This function can be used within another function to gather the function's
# input either from the arguments or from stdin.
# Notes:
#   - The tokenisation of the argument list is NOT maintained, that means, the
#     arguments are printed as a single string.
_get-input() {
  if [[ "$#" -gt 0 ]]
    then echo "$*"
  else
    echo "$(</dev/stdin)"
  fi
}

# Split arguments into two arrays separated by a delimiter.
# Usage:
#   _splitargs <array_name_1> <arrary_name_2> <delimiter> <args>...
# Args:
#   <array_name_1>  Name of array variable for elements before delimiter
#   <array_name_2>  Name of array variable for elements after delimiter
#   <delimiter>     Delimiter string 
#   <args>...       Argument sequence containing elements and delimiter
# Example:
#   _splitargs a1 a2 -- foo bar -- baz kux
# The above assigns ["foo" "bar"] to a variable named 'a1' and ["baz" "kux"] to
# a variable named 'a2'. These variables can be used in the calling context.
# Notes:
#   - The variable names DON'T need to be declared in the calling function, but
#     it's advisable to declare them with 'local' in order to keep them local.
#   - If <args>... does not contain the delimiter, then all elements are
#     assigned to <array_name_1> (and <array_name_2> is left empty)
#   - If <args>... contains multiple occurrences of the delimiter, then the
#     split happens at the first of these delimiters.
#   - The passed variable names must not be '__ref1' and '__ref2' as these are
#     internally used (otherwise, a "circular name reference" error occurs).
#   - The assignments to the passed in variable names are implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_splitargs() {
  local -n __ref1=$1 __ref2=$2
  local d=$3
  shift 3
  local i
  for i in $(seq "$#"); do
    if [[ "${!i}" = "$d" ]]; then
      __ref1=("${@:1:$(($i-1))}")  # Arguments before delimiter
      __ref2=("${@:$(($i+1))}")    # Arguments after delimiter
      return
    fi
  done
  # If no delimiter found
  __ref1=("$@")
}

#------------------------------------------------------------------------------#
#= Output functions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions print output intended to be processed or used by other
# functions or commands.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Print ~/.bashrc.* files in the order they are sourced by ~/.bashrc
_get-bashrc() {
  echo ~/.bashrc.path ~/.bashrc.lib ~/.bashrc.main ~/.bashrc.!(path|lib|main)
}

# List and filter variables
# Usage:
#   _list-vars [-nNvV <pat>] [-tT <attr>] [-l <len>] [-fs] [-c <cols>]
# Args:
#   -n|N <pat>:  postive/negative variable name filter
#   -v|V <pat>:  positive/negative variable value filter
#   -t|T <attr>: positive/negative attribute filter
#   -l <len>:    maximum length of printed variable values (default: 100)
#   -f:          print the full variable values (up to 2000 characters)
#   -s:          print only the variable names
#   -c <cols>:   columns to print (default: 1,2,3,4)
# Description:
#   Prints the variables matching the provided filters as a table consisting of
#   the following columns:
#     - 1: row number
#     - 2: attributes
#     - 3: variable name
#     - 4: variable value
#   The set of columns to print may be customised with the -c option. The -s
#   option is a shorthand for '-c 3' and prints only the variable names.
# Notes:
#   1. Lower-case options -n, -v, and -t allow specifying POSITIVE patterns.
#      For example '-n ^foo' selects all variables whose name starts with 'foo'.
#   2. Upper-case options -N, -V, and -T allow specifying NEGATIVE patterns.
#      For example, '-N ^foo' selects all variables whose name does NOT start
#      with 'foo'.
#   3. Multiple occurrences of the same lower-case options -n, -v, and -t are
#      conjoined with OR. For example, '-n ^foo -n ^bar' selects all variables
#      whose starts with 'foo' OR starts with 'bar'.
#   4. Multiple occurrences of the same upper-case options -N, -V, and -T are
#      conjoined wih AND. For example '-N ^foo -N ^bar' selects all variables
#      whose does NOT start with 'foo' AND does NOT start with 'bar'.
#   5. Different types of options (i.e. -n, -N, -v, -V, -t, and -T among each
#      other) are conjoined with AND. For example, '-n ^foo -t a' selects all
#      variables whose name starts with 'foo' AND have the 'a' attribute.
#   6. The above also hold for upper-case options. For example, '-n ^foo -N _'
#      selects all variables whose name starts with 'foo' AND whose name does
#      NOT contain an underline. As another example, '-n ^foo -T a' selects all
#      variables whose name starts with 'foo' AND do NOT have the 'a' attribute.
#   7. <pat> may be any pattern understood by AWK. Certain characters, such as
#      '(' and ')' must be escaped to not be interpreted by AWK.
#   8. In <attr>, the absence of any attribute can be specified with '-'.
#   9. Text variable values are printed with enclosing "...". Array variable 
#      values are printed with enclosing (...). These enclosing characters
#      must be taken into account when creating patterns with -v and -V.
#  10. The -l option is capped at 2000 characters. Similarly, the -f option
#      also truncates the variable values at 2000 characters. This limitation
#      is due to the maximum line length limit of 2048 characters of 'column'
#      which is used to format the output table.
#  11. The output rows are sorted alphabetically by variable name. This holds
#      even if the variable name column (column 3) is not printed.
_list-vars() {
  # Capture variables and add line numbers (indices) as first column
  local -r data=$(declare -p | __vars-format-declare | awk 'BEGIN { i = 1 }{ print i "\t" $0; i++; }')
  # Parse command-line arguments
  local -a pat_names_arr pat_names_i_arr pat_values_arr pat_values_i_arr attr_arr attr_i_arr
  local -ai columns=(1 2 3 4)
  local -i max_value_len=100
  local expect_n expect_N expect_v expect_V expect_t expect_T expect_l expect_c
  local a
  for a in "$@"; do
    case "$a" in
      -n) expect_n=1 ;;
      -N) expect_N=1 ;;
      -v) expect_v=1 ;;
      -V) expect_V=1 ;;
      -t) expect_t=1 ;;
      -T) expect_T=1 ;;
      -f) max_value_len=2000 ;;
      -l) expect_l=1 ;;
      -s) columns=(3) ;;
      -c) expect_c=1 ;;
      *)
        if _is-set "$expect_n"; then
          pat_names_arr+=("$a")
          expect_n=
        elif _is-set "$expect_N"; then
          pat_names_i_arr+=("$a")
          expect_N=
        elif _is-set "$expect_v"; then
          pat_values_arr+=("$a")
          expect_v=
        elif _is-set "$expect_V"; then
          pat_values_i_arr+=("$a")
          expect_V=
        elif _is-set "$expect_t"; then
          local attr=$(_parse-attributes "$a" '.*')
          _is-set "$attr" && attr_arr+=(".*$attr.*")
          expect_t=
        elif _is-set "$expect_T"; then
          local attr=$(_parse-attributes "$a" '.*')
          _is-set "$attr" && attr_i_arr+=(".*$attr.*")
          expect_T=
        elif _is-set "$expect_l"; then
          max_value_len=$([[ "$a" -gt 2000 ]] && echo 2000 || echo "$a")
          expect_l=
        elif _is-set "$expect_c"; then
          IFS=, read -a columns <<<"$a"
          #columns=($(echo "$a" | tr , '\n' | sort -u | sed -n '/^[1-4]$/p'))
          expect_c=
        else
          _err "Invalid option: $a"
          return  1
        fi
    esac
  done
  # Filter variables
  # Note: the reason that only indices are used is that 'comm' has a line
  # length limit of ~6000 characters
  local indices=$(cut -f 1 <<<"$data")
  [[ "${#attr_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter "$data" attr_arr 2 "$indices")
  [[ "${#attr_i_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter-inverted "$data" attr_i_arr 2 "$indices")
  [[ "${#pat_names_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter "$data" pat_names_arr 3 "$indices")
  [[ "${#pat_names_i_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter-inverted "$data" pat_names_i_arr 3 "$indices")
  [[ "${#pat_values_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter "$data" pat_values_arr 4 "$indices")
  [[ "${#pat_values_i_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter-inverted "$data" pat_values_i_arr 4 "$indices")
  echo "${columns[@]}"
  return
  echo "$data" |
    sed -n "$(for i in $indices; do echo "${i}p;"; done)" |
    _truncate-column '\t' 4 "$max_value_len" |
    cut -f 2- |
    _add-line-numbers -s $'\t' -u : |
    _filter-cols "${columns[@]}" |
    column -t -s $'\t'
}

# Get indices of vars matching any of given patterns AND given set of indices
__list-vars-filter() {
  local -r __data=$1 __indices=$4
  local -nr __patterns=$2
  local -ir __field=$3
  local __p __new_matches
  for __p in "${__patterns[@]}"; do
    __new_matches+=$'\n'$(echo "$__data" | awk -F '\t' '$'"$__field"' ~ /'"$__p"'/ {print $1}')
  done
  comm -12 <(echo "$__indices" | sort) <(echo "$__new_matches" | sed '/^$/d' | sort -u)
}

# Get indices of vars NOT matching given patterns AND matching given indices
__list-vars-filter-inverted() {
  local -r __data=$1
  local -nr __patterns=$2
  local -ir __field=$3
  local __indices=$4
  local __p
  for __p in "${__patterns[@]}"; do
    __indices=$(comm -12 <(echo "$__indices" | sort) <(echo "$__data" | awk -F '\t' '$'"$__field"' !~ /'"$__p"'/ {print $1}' | sort -u))
  done
  echo "$__indices"
}

# Format the output of 'declare -p' as a table with three columns
# Usage:
#   __vars-format-declare
# Description
#   Formats the output of any 'declare -p' command as a table with the following
#   three columns:
#     1. Attributes
#     2. Variable name
#     3. Variable value
#   Reads from stdin.
__vars-format-declare() {
  awk '
    {
      attr = $2
      gsub(/--/, "+", attr)
      gsub(/-/, "", attr)
      gsub(/+/, "-", attr)
      match($3, /^[^=]+/)
      name = substr($3, RSTART, RLENGTH)
      match($0, /=.*$/)
      value = substr($0, RSTART+1, RLENGTH)
      print attr "\t" name "\t" value
    }'
}

# Filter the columns of a table by column index
# Usage:
#   _filter-cols <col>... -- [-so <sep>] 
# Args:
#   <col>:     column index (starting at 1)
#   -s <sep>:  input field separator (default: '\t')
#   -o <sep>:  output field separator (default: '\t')
# TODO: if a 0 is in <columns>, the output is broken
_filter-cols() {
  local -ai columns
  local -a args
  _splitargs columns args -- "$@"
  _array-sort columns -u -n
  local fs='\t' ofs='\t'
  local expect_s expect_o
  local a
  for a in  "${args[@]}"; do
    case "$a" in
      -s) expect_s=1 ;;
      -o) expect_o=1 ;;
      *)
        if _is-set "$expect_s"; then
          fs=$a
          expect_s=
        elif _is-set "$expect_o"; then
          ofs=$a
          expect_o=
        else
          _err "Invalid argument: $a"
          return 1
        fi

    esac
  done
  awk -v fs="$fs" -v ofs="$ofs" -v cols="${columns[*]}" '
    BEGIN {
      split(cols, arr)
      FS = fs
      OFS = ofs
    }
    {
      for (i in arr) {
        if (arr[i] < 1 || arr[i] > NF ) delete arr[i]
      }
      if (length(arr) == 0) {
        for (i = 1; i <= NF; i++) arr[i] = i
      }
      output = ""
      for (i in arr) {
        output = output $arr[i]
        if (i < length(arr)) output = output OFS
      }
      print output
    }
  '
}

# Print value of a variable (for arrays, print array)
_get-var() {
  _ensure-variable "$1" || return 1
  declare -p "$1" | __vars-format-declare | column -t -s $'\t'
}
complete -v _get-var

# Print the attributes of a variable
# Usage:
#   _get-attributes <var-name> [-s]
# Args:
#   <var-name>: name of a variable
#   -s:         print only attribute names without descriptions
# Notes:
#   - If the variable has no attributes, the output is empty
#   - If <var-name> is not a variable, an error is returned
_get-attributes() {
  _ensure-variable "$1" || return 1
  local -n __ref=$1
  _describe-attributes "${__ref@a}" "$2"
}


# Parse a variable attribute specification
# Usage:
#   _parse-attributes <attr> [<sep>]
# Args:
#   <attr>:  a set of one or more attributes (e.g. 'i', 'ir')
#   <sep>:   separator between attributes in the output (default: "")
# Description:
#   Prints all valid attributes in the input in alphabetical order, discarding
#   any repeated and invalid attributes.
# Notes:
#   - Returns 1 if the output is empty (i.e. if there was no valid attribute
#     in the input).
#   - The separator may be a string of any length and may include characters
#     such as '\t' or '\n'.
_parse-attributes() {
  local -r attr=$1 sep=${2}
  echo "$attr" | sed "s/[^Aailnrtux-]//g" | grep -o . | sort -u | paste -s -d ' ' - | sed 's/ /'"$sep"'/g'
}

# Print a Select Graphic Rendition (SGR) code.
# Usage:
#   _sgr [<keyword>...]
# The available keywords are:
#    1. red[+]
#    2. green[+]
#    3. yellow[+]
#    4. blue[+]
#    5. magenta[+]
#    6. cyan[+]
#    7. white[+]
#    8. black[+]
#    9. bold
#   10. italic
#   11. dim
#   12. underline
#   13. reset
# The 8 colours without an appended + are the normal versions of these colours
# and appending a + means selecting the bright version of this colour. There
# may be any number of keywords and they may be in any order. However, the
# corresponding attributes are applied sequentially and a later keyword may
# override the effect of a previous keyword. For example 'red italic green'
# results in 'italic' and 'green' being select (the effect of 'red' is undone
# by the appearance of 'green' later in the list).
# Notes:
#   - The 'reset' keyword resets all previously specified attributes.
#   - If no keywords are specified, it has the same effect as specifying 'reset'
#     as the only or last keyword.
# Example:
#   echo "$(_sgr bold red)This is bold red. $(_sgr)This is normal."
# References:
#   - https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
_sgr() {
  local -a params
  local a
  for a in $@; do
    case "$a" in
      # Normal colours
      black)      params+=(30) ;;
      red)        params+=(31) ;;
      green)      params+=(32) ;;
      yellow)     params+=(33) ;;
      blue)       params+=(34) ;;
      magenta)    params+=(35) ;;
      cyan)       params+=(36) ;;
      white)      params+=(37) ;;
      # Bright colours
      black+)     params+=(90) ;;
      red+)       params+=(91) ;;
      green+)     params+=(92) ;;
      yellow+)    params+=(93) ;;
      blue+)      params+=(94) ;;
      magenta+)   params+=(95) ;;
      cyan+)      params+=(96) ;;
      white+)     params+=(97) ;;
      # Modifiers
      bold)       params+=(1) ;;
      dim)        params+=(2) ;;
      italic)     params+=(3) ;;
      underlined) params+=(4) ;;
      reset)      params+=(0) ;;
    esac
  done
  local IFS=';'
  printf "\e[${params[*]}m"
}

#------------------------------------------------------------------------------#
#= User message functions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions print user-facing output messages.
#
# CAUTION: these functions are intended to be used in other functions.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Print an error message to stderr
# Usage:
#   _err <msg>
# Args:
#   <msg>: the error message
# Notes:
#   - The message ideally consists of a single line
#   - The prefix 'Error: ' is automatically added to the message in the output
#   - The output includes the complete function call stack
#   - The output is coloured if stderr is directed to a terminal (it is not
#     coloured if stderr is directed to anything else but a terminal)
_err() {
  local msg=$1
  # Format function call stack
  local -a stack
  _array-cp FUNCNAME stack
  # Remove _array-cp and _err from the call stack
  _array-rmi stack stack 0 1
  _array-rev stack stack
  local stack_str=$(_array-ls stack " > ")
  # Print message and function call stack
  _cond-sgr-msg red -- "Error:\n  $msg\nCall stack:\n  $stack_str\n"
}

# TODO:
#   - Omit this function and only use the documentation function for the usage
#   - Make <msg> a single argument and omit need for splitargs
# Print usage message for a function to stderr.
# Usage:
#   _print-usage-msg <msg>... [-- <func-stack-index>]
# The output is highlighed with Select Graphic Rendition (SGR) codes if stderr
# is directed to the terminal. The <func-stack-index> argument is the index in
# the function call stack of the function name to print. Its default value is
# 1, which corresponds to the immediate caller of _print-usage-msg.
# Notes:
#   - <msg> may include 'echo -e' escape codes such as '\n' and '\t'
_print-usage-msg() {
  local msg_arr index_arr
  _splitargs msg_arr index_arr -- "$@"
  _cond-sgr-msg cyan bold -- \
    "Usage:\n  ${FUNCNAME["${index_arr[0]:-1}"]:-<unknown>} ${msg_arr[@]}\n" -- \
    2
}

#------------------------------------------------------------------------------#
#= Conditional functions
#------------------------------------------------------------------------------#

# Print a message if file descriptor is directed to terminal.
# Usage:
#   _cond <msg>... [-- <fd>]
# The default value for <fd> is 1, which corresponds to stdout. That means, the
# function prints the message to stdout IF stdout is directed to the terminal.
# To use stderr instead, append the delimiter -- followed by 2 to the argument
# list. In that case, the message is written to stderr IF stderr is directed
# to the terminal.
# Notes:
#   - The message is printed without an implicit newline at the end.
#   - All escape codes understood by 'echo -e' (such as '\n' or '\t') may be
#     included in the message.
_cond() {
  local msg_arr fd_arr
  _splitargs msg_arr fd_arr -- "$@"
  local fd=${fd_arr[0]:-1}
  _ensure-file-descriptor "$fd" || return 1
  if [[ -t "$fd" ]]; then
    echo -ne "${msg_arr[@]}" >&"$fd"
  fi
}

# Print an SGR code if file descriptor is directed to terminal.
# Usage:
#   _cond-sgr <sgr-arg>... [-- <fd>]
_cond-sgr() {
  local -a sgr_arr fd_arr
  _splitargs sgr_arr fd_arr -- "$@"
  local fd=${fd_arr[0]:-1}
  _ensure-file-descriptor "$fd" || return 1
  if [[ -t "$fd" ]]; then
    _sgr "${sgr_arr[@]}" >&"$fd"
  fi
}

# Print an SGR-formatted message if file descriptor is directed to terminal.
# Usage:
#   _cond-sgr-msg <sgr-arg>... -- <msg>... [-- <fd>]
# TODO:
#   - Make <msg> a single argument and avoid need for -- (change order of <msg>
#     and <sgr-arg>...)
#   - Create separate functions for stdout and stderr to avoid need for [-- <fd>]
#   - Make versions for printing lines (auto-adding newline) and other for
#     not printing a newline
_cond-sgr-msg() {
  local -a sgr_arr msg_fd_arr msg_arr fd_arr
  _splitargs sgr_arr msg_fd_arr -- "$@"
  _splitargs msg_arr fd_arr -- "${msg_fd_arr[@]}"
  local fd=${fd_arr[0]:-1}
  _ensure-file-descriptor "$fd" || return 1
  local msg="${msg_arr[@]}"
  if [[ -t "$fd" ]]; then
    msg="$(_sgr "${sgr_arr[@]}")${msg}$(_sgr)"
  fi
  echo -ne "$msg" >&"$fd"
}

#------------------------------------------------------------------------------#
#= Predicate funtions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions check a condition and return either 0 (true) or 1 (false).
#
# Usage example:
#
#   if _is-XXX; then
#     ...
#   fi
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Check whether running on macOS
_is-mac() {
  [[ "$OSTYPE" =~ darwin ]]
}

# Check whether running on Linux
_is-linux() {
  [[ "$OSTYPE" =~ linux  ]]
}

# Check whether running on a WSL distribution of Linux
# References:
#   - https://learn.microsoft.com/en-us/windows/wsl/install
#   - https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux
_is-wsl() {
  _is-linux && [[ -n "$WSL_DISTRO_NAME" ]]
}

# Check whether the provided value is set (i.e. non-empty)
# Notes:
#   - Returns 1 (false) if no value is provided.
_is-set() {
  [[ -n "$1" ]]
}

# Check whether the provided value is empty (or non-existent)
# Notes:
#   - Returns 0 (true) if no value is provided.
_is-empty() {
  [[ -z "$1" ]]
}

# Check whether a number is even
_is-even() {
  (($1 % 2 == 0))
}

# Check whether a number is odd
_is-odd() {
  (($1 % 2 != 0))
}

# Check whether a number is an integer
_is-int() {
  _is-pos-int "$1" || _is-neg-int "$1"
}

# Check whether a value is a positive integer (including 0)
_is-pos-int() {
  [[ "$1" =~ ^[0-9]+$ ]]
}

# Check whether a number is a negative integer
_is-neg-int() {
  [[ "$1" =~ ^-[0-9]+$ ]]
}

# Check whether the variable with the provided name is set (i.e. non-empty)
# Notes:
#   - Returns 1 (false) if no variable with the provided name exists.
_has-value() {
  _is-var-name "$1" || return 1
  local -n __ref=$1
  _is-set "$__ref"
}

# Check whether there is a variable with the provided name
_is-variable() {
  declare -p -- "$1" &>/dev/null
}

# Describe one or more attributes
# Usage:
#   _describe-attr [<attr>...]
# Args:
#   [<attr>]: a single attribute
# Notes:
#   - If <attr> is omitted, then all attributes are described
#   - The full list of attributes is: A, a, i, l, n, r, t, u, x
_describe-attr() {
  [[ "$#" -eq 0 ]] && set -- A a i l n r t u x
  local a
  for a in "$@"; do
    case "$a" in
      A) echo "A: associative array" ;;
      a) echo "a: indexed array" ;;
      i) echo "i: integer" ;;
      l) echo "l: lower case" ;;
      n) echo "n: name reference" ;;
      r) echo "r: read-only" ;;
      t) echo "t: trace" ;;
      u) echo "u: upper case" ;;
      x) echo "x: export" ;;
    esac
  done
}

# Check whether a variable has a specific set of attributes
# Usage:
#   _has-attr <var-name> <attr-spec>...
# Args:
#   <var-name>:  name of a variable
#   <attr-spec>: an attribute specification
# Notes:
#   - An <attr-spec> may contain multiple attributes
#   - The attributes within an <attr-spec> are ANDed
#   - The various <attr-spec> are ORed
#   - Example: "Ai a" translates to ("A" AND "i") OR "a"
#   - The special attribute '-' may be used to mean "no attributes"
#   - The full list of attributes is: A, a, i, l, n, r, t, u, x
_has-attr() {
  _ensure-arg-count "$@" 2 "<var-name> <attr-spec>"
  local -n __ref=$1
  shift
  # Attributes of the variable
  local target=$(echo "${__ref@a}" | grep -o .)
  local attr_spec attr match=FALSE
  # Or between <attr-spec>
  for attr_spec in "$@"; do
    # AND for attributes within an <attr-spec>
    while read attr; do
      if [[ "$attr" = - && -z "$target" ]]; then
        match=TRUE
      elif echo "$target" | grep -q "^$attr$"; then
        match=TRUE
      else
        match=FALSE
        break
      fi
    done <<<$(echo "$attr_spec" | grep -o .)
    [[ "$match" = TRUE ]] && break
  done
  [[ "$match" = TRUE ]]
}


#------------------------------------------------------------------------------#
# Old
#------------------------------------------------------------------------------#

# Print variable attributes
# Usage:
#   _describe-attributes [<attr-str>] [-s]
# Args:
#   <attr-str>: a string of one or more attributes (examples: 'a', 'iAau')
#   -s:         print only attribute names without descriptions
# Notes:
#   - If <attr-str> is omitted, all attributes are printed
#   - For the full list and description of attributes, see 'declare' [1]
# References:
#   [1] https://www.gnu.org/software/bash/manual/bash.html#index-declare
# TODO: make default option print all attributes on one line without spaces
_describe-attributes() {
  [[ "${@: -1}" = -s ]] && local short=1
  local data=$(cat <<EOF
A (associative array)
a (indexed array)
i (integer)
l (lower case)
n (name reference)
r (read-only)
t (trace)
u (upper case)
x (export)
EOF
  )
  # Print all attributes
  if [[ "$#" -eq 0 || ("$#" -eq 1 && "$1" = -s) ]]; then
    echo "$data"
  # Print only specified attributes
  else
    local -a attributes=($(_parse-attributes "$1" ' '))
    local a
    for a in "${attributes[@]}"; do
      echo "$data" | sed -n "/^$a /p"
    done
  fi |
  # Format as short or normal output based on -s option
  if _is-set "$short"; then
    cut -c 1
  else
    cat
  fi
}

# TODO: combine with *-any-of() function and define 'aiu' as AND and 'a' 'i' 'u'
#       as OR. This allows combinations of AND and OR. Check how easy it is to
#       implement this.
# TODO: introduce -- as a special attribute to mean "no attributes"
# Check whether a variable has all of the specified attributes
# Usage:
#   _has-attributes <var-name> <attr-str>...
# Args:
#   <var-name>: name of a variable
#   <attr-str>: a string of one or more attributes (examples: 'a', 'iAau')
# Notes:
#   - The values of all <attr-str> are concatenated to a unified input, i.e.,
#     'a' 'i' 'u' is the same as 'aiu'
#   - If the attribute input is empty, 1 is returned
_has-attributes() {
  #_ensure-variable "$1" || return 1
  local -n __ref=$1
  shift
  local -a __input
  # If input is empty or contains invalid attributes, return 1
  __input=($(_parse-attributes "$@" ' ')) || return 1
  local __i
  for __i in "${__input[@]}"; do
    [[ "${__ref@a}" =~ "$__i" ]] || return 1
  done
}
complete -v _has-attributes

# TODO: introduce - as a special attribute to mean "no attributes"
# Check whether a variable has any of the specified attributes
# Usage:
#   _has-attributes-any-of <var-name> <attr-str>...
# Args:
#   <var-name>: name of a variable
#   <attr-str>: a string of one or more attributes (examples: 'a', 'iAau')
# Notes:
#   - The values of all <attr-str> are concatenated to a unified input, i.e.,
#     'a' 'i' 'u' is the same as 'aiu'
#   - If the attribute input is empty, 1 is returned
_has-attributes-any-of() {
  _ensure-variable "$1" || return 1
  local -n __ref=$1
  shift
  local __a
  for __a in $(_parse-attributes "$@" ' '); do
    [[ "${__ref@a}" =~ "$__a" ]] && return 0
  done
  return 1
}
complete -v _has-attributes-any-of

#------------------------------------------------------------------------------#
# End of Old
#------------------------------------------------------------------------------#

# Check whether a variable is an indexed array
# Usage:
#   _is-indexed-array <var-name>
_is-indexed-array() {
  _has-attributes "$1" a
}

# Check whether a variable is an associative array
# Usage:
#   _is-associative-array <var-name>
_is-associative-array() {
  _ensure-variable "$1" || return 1
  _has-attributes "$1" A
}

# Check whether a variable is either an indexed or an associative array 
# Usage:
#   _is-array <var-name>
_is-array() {
  _ensure-variable "$1" || return 1
  _has-attributes-any-of "$1" Aa
}

# Check whether a variable is read-only
# Usage:
#   _is-read-only <var-name>
_is-read-only() {
  _ensure-variable "$1" || return 1
  _has-attributes "$1" r
}

# Check whether the argument is the name of a shell function
_is-function() {
  [[ "$(type -t "$1")" = function ]]
}
complete -A function _is-function

# Check whether a given command is a shell alias
_is-alias() {
  [[ "$(type -t "$1")" = alias ]]
}
complete -a _is-alias

# Check whether a given command is a shell builtin
_is-builtin() {
  [[ "$(type -t "$1")" = builtin ]]
}
complete -b _is-builtin

# Check whether a given command is an executable file in the PATH
_is-exec-file() {
  [[ "$(type -t "$1")" = file ]]
}
complete -c _is-exec-file

# Check whether a given command exists (i.e. is either an executable file in 
# the path, an alias, a function, or a shell builtin)
_is-cmd() {
  _is-exec-file "$1" || _is-alias "$1" || _is-function "$1" || _is-builtin "$1"
}
complete -c _is-cmd

# Check whether a given Homebrew formula or cask is installed
# Note: also checks whether Homebrew is installed, and aborts otherwise
_is-homebrew-poured() {
  _ensure-installed brew || return 1
  brew ls --versions "$1" >/dev/null || brew ls --cask --versions "$1" >/dev/null
}

#------------------------------------------------------------------------------#
#= Enforcement funtions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions enforce a specific condition by printing an error message
# and returning 1, if the condition is not met.
#
# CAUTION: these functions are intended to be used in other functions.
#
# Example usage (in other function):
#   
#   _ensure-XXX || return 1
# 
# In the above example, the function aborts if the condition is not met.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Ensure that the argument is a valid command.
_ensure-installed() {
  if ! _is-cmd "$1"; then
    _err "'$1' is not installed"
    return 1
  fi
}

# Ensure that argument is a valid file descriptor.
# Note: the list of accepted file descriptors is hardcoded to 0, 1, and 3.
_ensure-file-descriptor() {
  if [[ ! "$1" =~ 0|1|2 ]]; then
    _err "'$1' is not a valid file descriptor"
    return 1
  fi
}

_ensure-array() {
  if ! _is-array "$1"; then
    _err "'$1' is not an array"
    return 1
  fi
}

# Ensure that the passed variable name belongs to an indexed array
# Usage:
#   _ensure-indexed-array <array-name>
_ensure-indexed-array() {
  if ! _is-indexed-array "$1"; then
    _err "'$1' must be an indexed array"
    return 1
  fi
}

# TODO: create variants with: 2, 2-, 2-3, -3
# Ensure that an argument list consists of a specific number of arguments
# Usage:
#   _ensure-arg-count <args>... <n>
# Args:
#   <args>...: the argument list to check
#   <n>:       the number specification with format '[min][-][max]'
# Notes:
#   - The number specification <n> can have the following formats:
#     - n:   exactly n arguments
#     - n-:  at least n arguments
#     - -n:  at most n arguments
#     - n-m: between n and m arguments
_ensure-arg-count() {
  local n=${@: -1}
  set -- "${@:1:$(($#-1))}"
  local n_min n_max n_msg
  if [[ "$n" =~ ^[0-9]+$ ]]; then
    n_min=$n
    n_max=$n
    n_msg=$n
  elif [[ "$n" =~ ^[0-9]+-$ ]]; then
    n_min=${n%-}
    n_max=$(getconf ARG_MAX)
    n_msg="at least $n_min"
  elif [[ "$n" =~ ^-[0-9]+$ ]]; then
    n_min=0
    n_max=${n#-}
    n_msg="at most $n_max"
  elif [[ "$n" =~ ^[0-9]+-[0-9]+$ ]]; then
    n_min=${a%-*}
    n_max=${a#*-}
    n_msg="between $n_min and $n_max"
  else
    _err "$FUNCNAME: invalid number specification: $n"
    return 1
  fi
  if [[ "$#" -lt "$n_min" || "$#" -gt "$n_max" ]]; then
    _err "'${FUNCNAME[1]}' must have $n_msg argument(s)"
    return 1
  fi
}

# Ensure that the argument is a valid variable name.
_ensure-var-name() {
  if ! _is-var-name "$1"; then
    _err "'$1' is not a valid variable name"
    return 1
  fi
}

# Ensure that the provided NAME is a declared variable
_ensure-variable() {
  if ! _is-variable "$1"; then
    _err "'$1' is not a variable"
    return 1
  fi
}

# TODO: change to _is-identifier()
# Check whether the argument is a valid variable name.
# Usage:
#   _is-var-name <name>
# Note: this function just checks whether the name adheres to the naming
# restrictions, not whether a variable with that name is declared or assigned.
_is-var-name() {
  [[ "$1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]
}

#------------------------------------------------------------------------------#
#= PATH manipulation
#------------------------------------------------------------------------------#

# Print the current value of PATH
# Usage:
#   _path
_path() {
  echo "$PATH"
}

# Read PATH into an indexed array
# Usage:
#   _path-parse <name>
# Args:
#   <name>: name of the array to create
# Notes:
#   - If <name> doesn't exist, it is created, if it already exists, it is
#     overwritten
_path-parse() {
  # TODO: check that $1 is a valid variable name
  _array-parse "$1" : <<<"$PATH"
}

# Check whether PATH contains an entry that matches the specified pattern
# Usage:
#   _path-has <pat>
# Args:
#   <pat>: regex pattern 
# Notes:
#   - The value of <pat> may be any valid regex. The regex is automatically
#     anchored with ^ and $ at the beginning and end, respectively.
# Examples:
#   Test whether PATH contains any entries containing the substring 'homebrew':
#     _path-has '.*homebrew.*'
_path-has() {
  local -a path
  _path-parse path
  _array-has path "$1"
}

# Delete duplicate entries from PATH
# Usage:
#   _path-uniq
# Notes:
#   - If a duplicate PATH entry is detected, the first occurrence of this entry
#     is kept and all other ocurrences are deleted
_path-uniq() {
  local -a path
  _path-parse path
  _array-uniq path path
  PATH=$(_array-ls path :)
}

# Delete entries that are not existing directories from PATH
# Usage:
#   _path-rectify
_path-rectify() {
  local -a path delete
  _path-parse path
  local elt
  for elt in "${path[@]}"; do
    if [[ ! -d "$elt" ]]; then
      delete+=("$elt")
    fi
  done
  _array-rm path path "${delete[@]}"
  PATH=$(_array-ls path :)
}

# Prepend one or more entries to the beginning of the PATH
# Usage:
#   _path-prepend <entry>...
# Args:
#   <entry>: absolute path of a directory on the local machine
# Notes:
#   - If PATH already contains the entry, the existing entry is deleted before
#     adding the new entry 
#   - Multiple entries are added so that the first argument will be the first
#     entry in PATH, the second argument the second entry, and so on
#   - This function does NOT check whether the entries are valid directories
# Examples:
#   Prepend multiple entries (result is "/foo:/bar:/baz:$PATH"):
#     _path-prepend /foo /bar /baz
_path-prepend() {
  local -a path entries
  _path-parse path
  entries=("$@")
  _array-rev entries entries
  local e
  for e in "${entries[@]}"; do
    _array-rm path path "$e"
    _array-insert path path "$e" 0
  done
  PATH=$(_array-ls path :)
}

# Append one or more entries to the end of the PATH
# Usage:
#   _path-append <entry>...
# Args:
#   <entry>: absolute path of a directory on the local machine
# Notes:
#   - If PATH already contains the entry, the existing entry is deleted before
#     adding the new entry 
#   - Multiple entries are added so that the last argument will be the last
#     entry in PATH, the second-last argument the second-last entry, and so on
#   - This function does NOT check whether the entries are valid directories
# Examples:
#   Append multiple entries (result is "$PATH:/foo:/bar:/baz"):
#     _path-append /foo /bar /baz
_path-append() {
  local -a path entries
  _path-parse path
  entries=("$@")
  local e
  for e in "${entries[@]}"; do
    _array-rm path path "$e"
    _array-insert path path "$e" -1
  done
  PATH=$(_array-ls path :)
}

# Delete one or more entries from PATH
# Usage:
#   _path-rm <pat>...
# Args:
#   <pat>: regex pattern
# Notes:
#   - The value of <pat> may be any valid regex. The regex is automatically
#     anchored with ^ and $. That means, the pattern "foo" matches complete
#     entries "foo". For matching the substring "foo", use '.*foo.*'.
# Examples:
#   Delete all PATH entries containing the substring '/System':
#     _path-rm '.*/System.*'
_path-rm() {
  local -a path
  _path-parse path
  _array-rm path path "$@"
  PATH=$(_array-ls path :)
}

#-----------------------------------------------------------------------------#
#= Array processing (indexed arrays only)
#------------------------------------------------------------------------------#

# TODO: complete argument checks for all functions:
#   - type of arguments
#   - number or arguments

# Check whether an indexed array is empty
# Usage:
#   _array-is-empty <name>
# Args:
#   <name>: the name of the array to check
# Notes:
#   - The array must exist. If the array doesn't exist, or is not an indexed
#     array, an error is returned.
_array-is-empty() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_is_empty__in=$1
  [[ "${#__array_is_empty__in[@]}" -eq 0 ]]
}

# Get the size of an indexed array
# Usage:
#   _array-size <name>
# Args:
#   <name>: the name of the array whose size to determine
_array-size() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_size__in=$1
  echo "${#__array_size__in[@]}"
}

# Get the index of the last element of an indexed array
# Usage:
#   _array-end <name>
# Args:
#   <name>: the name of the array
# Notes:
#   - If the array is empty, then an empty string is returned
_array-end() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_last_index__in=$1
  if ! _array-is-empty __array_last_index__in; then
    echo "$(($(_array-size __array_last_index__in)-1))"
  fi
}

# Check whether an indexed array contains an element matching a pattern
# Usage:
#   _array-has <name> <pat>
# Args:
#   <name>: name of the array
#   <pat>:  regex pattern 
# Notes:
#   - The value of <pat> may be any valid regex. The regex is automatically
#     anchored with ^ and $ at the beginning and the end, respectively.
#   - The function returns true if the array contains at least one element
#     matching the pattern in <pat>
_array-has() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_has__array=$1
  local __pat=$2
  local __elt
  for __elt in "${__array_has__array[@]}"; do
    # Regex must not be quoted
    if [[ "$__elt" =~ ^$__pat$ ]]; then
      return
    fi
  done
  return 1
}

# List the elements of an indexed array
# Usage:
#   _array-ls <name> [<delim>]
# Args:
#   <name>:    name of the array
#   [<delim>]: delimiter to separate array elements (default: $'\n')
# Notes:
#   - By default, array elements are separated by a newline
#   - The delimiter can be customised to be an arbitrary string
#   - The delimiter may include ANSI-C quoted strings ($'...'), such as $'\n'
#     for a newline, $'\t' for a tab, etc. (see [1]).
# References:
#   [1] https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
_array-ls() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_ls__in=$1
  local __delim=${2:-$'\n'}
  _array-is-empty __array_ls__in && return
  local __out=${__array_ls__in[0]}
  local __elt
  for __elt in "${__array_ls__in[@]:1}"; do
    __out+=$__delim$__elt
  done
  echo "$__out"
}

# Create a copy of an indexed array
# Usage:
#   _array-cp <in-name> <out-name>
# Args:
#   <in-name>:  name of the array to copy
#   <out-name>: name of the copy to create
# Notes:
#   - If <out-name> doesn't exist, it is created, if it already exists, it is
#     overwritten
_array-cp() {
  _ensure-indexed-array "$1" || return 1
  _ensure-variable "$1" || return 1
  _ensure-var-name "$2" || return 1
  local -n __array_cp__in=$1
  local -n __array_cp__out=$2
  # Works with newlines in array elements and with changed IFS
  __array_cp__out=("${__array_cp__in[@]}")
}

# Reverse the elements of an indexed array
# Usage:
#   _array-rev <in-name> <out-name>
# Args:
#   <in-name>:  name of the array to reverse
#   <out-name>: name of the array to save the result to
# Notes:
#   - If <out-name> is already assigned to a variable, it is overwritten
#   - To perform the operation in-place on the input array, use the same array
#     for both <in-name> and <out-name>
_array-rev() {
  _ensure-indexed-array "$1" || return 1
  _ensure-var-name "$1" && _ensure-array "$1" || return 1
  _ensure-var-name "$2" || return 1
  local -n __array_rev__in=$1
  local -n __array_rev__out=$2
  if _array-is-empty __array_rev__in; then
    __array_rev__out=()
  else
    local __i
    local -a __array_rev__tmp
    for __i in $(seq -1 "-$(_array-size __array_rev__in)"); do
      __array_rev__tmp+=(${__array_rev__in[$__i]})
    done
    _array-cp __array_rev__tmp __array_rev__out
  fi
}

# Delete elements matching one or more patterns from an indexed array
# Usage:
#   _array-rm <in-name> <out-name> <pat>...
# Args:
#   <in-name>:  name of the input array
#   <out-name>: name of the output array in which to save the result
#   <pat>:      regex pattern to match against the array elements
# Notes:
#   - The value of <pat> may be any valid regex. The regex is automatically
#     anchored with ^ and $ at the beginning and end, respectively.
#   - A single <pat> may match, and thus delete, multiple array elements
#   - If <out-name> doesn't exist, it is created, if it already exists, it is
#     overwritten
#   - Use the same array name for both <in-name> and <out-name> to perform the
#     operation in-place on the input array
# Examples:
#   Delete all elements starting with an upper or lower-case F:
#     _array-rm a b '[Ff].*'
#   Delete all elements with the value 'foo' or 'bar':
#     _array-rm a b foo bar
_array-rm() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_rm__in=$1 
  local -n __array_rm__out=$2
  # Working copy of input array (will be mutated)
  local -a __array_rm__in_copy
  _array-cp __array_rm__in __array_rm__in_copy
  local __pat
  for __pat in "${@:3}"; do
    local __i
    for __i in ${!__array_rm__in_copy[@]}; do
      # Regex must not be quoted
      if [[ "${__array_rm__in_copy[$__i]}" =~ ^${__pat}$ ]]; then
        unset "__array_rm__in_copy[$__i]"
      fi
    done
  done
  _array-cp __array_rm__in_copy __array_rm__out
}

# Delete elements at one or more indices from an indexed array
# Usage:
#   _array-rmi <in-name> <out-name> <index>...
# Args:
#   <in-name>:  name of the input array
#   <out-name>: name of the output array in which to save the result
#   <index>:    index of an element to delete
# Notes:
#   - Repeated, invalid, and non-existing items in the index list are ignored.
#     For example,
#       _array-rmi in out 0 0 0 foo 1000 0
#     The above results only in the removal of index 0 (assuming that the input
#     array has less than 1001 elements).
#   - Negative indices may be used, which resolve to an index relative to the
#     end of the array: -1 translates to the last array element, -2 to the
#     second-last, and so on, until -n which translates to the first array
#     element (if n is the size of the array). If the translated negative index
#     is out of the bounds of the array, then it is ignored.
#   - The indices of the elements in the output array are updated to be
#     consecutive starting from 0
#   - If <out-name> doesn't exist, it is created, if it already exists, it is
#     overwritten
#   - Use the same array name for both <in-name> and <out-name> to perform the
#     operation in-place on the input array
_array-rmi() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_rmi__in=$1 
  local -n __array_rmi__out=$2
  local __array_rmi__in_size=$(_array-size __array_rmi__in)
  # Working copy of input array (will be mutated)
  local -a __array_rmi__in_copy
  _array-cp __array_rmi__in __array_rmi__in_copy
  local __i 
  for __i in "${@:3}"; do
    # Normal indices
    if [[ "$__i" =~ ^[0-9]+$ ]]; then
      unset "__array_rmi__in_copy[$__i]"
    # Negative indices (relative to end of array): convert to absolute indices
    elif [[ "$__i" =~ ^-[0-9]+$ ]]; then
      __i=$((__array_rmi__in_size + __i))
      if [[ "$__i" -ge 0 ]]; then
        unset "__array_rmi__in_copy[$__i]"
      fi
    fi
  done
  _array-cp __array_rmi__in_copy __array_rmi__out
}

# Delete duplicate elements from an indexed array
# Usage:
#   _array-uniq <in-name> <out-name>
# Args:
#   <in-name>:  name of the input array
#   <out-name>: name of the output array in which to save the result
# Notes:
#   - If a duplicate element is detected, the first occurrence of this element
#     is kept and all other occurrences are deleted
#   - If <out-name> doesn't exist, it is created, if it already exists, it is
#     overwritten
#   - Use the same array name for both <in-name> and <out-name> to perform the
#     operation in-place on the input array
_array-uniq() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_uniq__in=$1 
  local -n __array_uniq__out=$2
  local -a __array_uniq__tmp
  local __elt
  for __elt in "${__array_uniq__in[@]}"; do
    if ! _array-has __array_uniq__tmp "$__elt"; then
      __array_uniq__tmp+=("$__elt")
    fi
  done
  _array-cp __array_uniq__tmp __array_uniq__out
}

# Insert a new element at the specified index in an indexed array
# Usage:
#   _array-insert <in-name> <out-name> <elt> <index>
# Args:
#   <in-name>:  name of the input array
#   <out-name>: name of the output array in which to save the result
#   <elt>:      value to insert into the array
#   <index>:    index at which to insert the value
# Notes:
#   - The value <elt> becomes the new element at index <index> in the array.
#     That means, all elements after <index> have their index increased by 1
#   - Negative indices may be used, which resolve to an index relative to the
#     end of the array: -1 translates to the last array element, -2 to the
#     second-last, and so on, until -n which translates to the first array
#     element (if n is the size of the array)
#   - If <index> is out of the bounds of the array or invalid, it is ignored
#     and no changes are made to the array
#   - If <out-name> doesn't exist, it is created, if it already exists, it is
#     overwritten
#   - Use the same array name for both <in-name> and <out-name> to perform the
#     operation in-place on the input array
_array-insert() {
  _ensure-indexed-array "$1" || return 1
  local -n __array_insert__in=$1 
  local -n __array_insert__out=$2
  local __value=$3
  local __target_index=$4
  local __array_insert__in_size=$(_array-size __array_insert__in)
  # Ignore invalid indices by setting them to an out-of-bound index
  if ! _is-int "$__target_index"; then
    __target_index=-1
  # Convert negative indices (relative to end of array) to absolute indices
  elif _is-neg-int "$__target_index"; then
    # E.g. size=4 ([0][1][2][3]): -1 => [4], -2 => [3], etc.
    __target_index=$((__array_insert__in_size + __target_index + 1))
  fi
  local -a __array_insert__tmp
  local __i
  for __i in "${!__array_insert__in[@]}"; do
    if [[ "$__i" -eq "$__target_index" ]]; then
      __array_insert__tmp+=("$__value")
    fi
    __array_insert__tmp+=("${__array_insert__in[$__i]}")
  done
  # Insert as the new last element (not covered by above loop)
  if [[ "$__target_index" -eq "$__array_insert__in_size" ]]; then
    __array_insert__tmp+=("$__value")
  fi
  _array-cp __array_insert__tmp __array_insert__out
}

# Parse stdin into an indexed array
# Usage:
#   _array-parse <name> [<delim>]
# Args:
#   <name>:    name of the array to create
#   [<delim>]: array element delimiter (default: $'\n')
# Notes:
#   - Do NOT use this function in a pipe, but instead redirect input to it
#     with e.g. file redirection (<), a here doc (<<), or a here string (<<<).
#     For example:
#         _array-parse arr $'\n\n' <file
#         _array-parse arr :: <<<foo::bar::baz
#         _array-parse arr <<<$(ls -l)
#     If the function is used in a pipe (e.g. echo a:b | _array-parse arr :),
#     the function is executed in a sub-shell and thus the array <name> will
#     also be created in the sub-shell and thus won't be accessible from the
#     current shell (this is the same behaviour as with readarray/mapfile).
#   - The value of <delim> may be a string of any length and may include:
#       1. ANSI-C quoted strings [1]
#       2. Glob patterns [2]
#   - Examples of valid <delim> expressions include:
#       - $'\n\n':       two consecutive newlines
#       - '[.:] ':       a period or column followed by a space
#       - '[[:punct:]]': any punctuation character
#   - To use character sequences belonging to ANSI-C quoted strings and glob
#     patterns in the delimiter, they must be quoted with a backslash. These
#     character sequences include (assuming 'extglob' is enabled): 
#         $'...', *, ?, [...], ?(...), *(...), +(...), @(...), !(...)
#     For example, to use ** in the delimiter, use '\*\*'. To use a backslash
#     in the delimiter, escape it with another backslash ('\\').
#   - If 'extglob' is enabled, the 'extglob' patterns (?(...), etc.) CAN'T be
#     used in their intended way in <delim>, e.g. to define delimiters of
#     variable length. This is because the matched length of these patterns is
#     determined by the operator in the parameter expansion [3] expressions
#     that are used internally (i.e. %% vs. % and ## vs #).
#   - If <name> doesn't exist, it is created, if it already exists, it is
#     overwritten
#   - The following workaround can be used for using the function as the LAST
#     command of a pipe:
#         shopt -s lastpipe  # Enable lastpipe [4]
#         set +o monitor     # Disable job control [5]
#     However, this only works if the function is the last command of the pipe,
#     otherwise, there is no effect.
# References:
#   [1] https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting
#   [2] https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching
#   [3] https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion
#   [4] https://www.gnu.org/software/bash/manual/bash.html#The-Shopt-Builtin
#   [5] https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin
_array-parse() {
  local -n __array_parse__out=$1
  local __delim=${2:-$'\n'}
  local __input_cur __input_next=$(cat)
  __array_parse__out=()
  while [[ "$__input_next" != "$__input_cur" ]]; do
      __input_cur=$__input_next
      __array_parse__out+=("${__input_cur%%$__delim*}")
      __input_next=${__input_cur#*$__delim}
  done
}

#------------------------------------------------------------------------------#
# TODO: check whether these functions are necessary
#------------------------------------------------------------------------------#

# Sort an array
# Usage:
#   _array-sort <array> [-u] [-n]
# Args:
#   <array>: name of an array
#   -u:      suppress repeated array elements
#   -n:      sort in numerical rather than alphabetical order
_array-sort() {
  local -n __array=$1
  [[ "${#__array[@]}" -eq 0 ]] && return
  local __arg_u __arg_n
  local __a
  for __a in "${@:2}"; do
    case "$__a" in
      -u) __arg_u=-u ;;
      -n) __arg_n=-n ;;
      *)
        _err "Invalid argument: $__a"
        return 1
    esac
  done
  readarray -t __array <<<$(_array-ls __array | sort $__arg_u $__arg_n)
}

# Return the type of an array variable.
# Usage:
#   _array-type <array-name>
# Returns either 'indexed' or 'associative'. If the passed name does not belong
# to an array variable, the function returns an error.
_array-type() {
  _ensure-arg-count "$@" 1 "<array-name>" && _ensure-var-name "$1" && _ensure-array "$1" || return 1
  local -n __ref=$1
  case "${__ref@a}" in
    a) echo indexed ;;
    A) echo associative ;;
  esac
}

#------------------------------------------------------------------------------#
#= Miscellaneous functions
#------------------------------------------------------------------------------#

# List all the types of a command.
# Usage:
#   _type [-s] <cmd>
# Lists all the types (function, alias, file, or builtin) for <cmd> in order
# of precedence. For files, functions, and aliases, the source file is also
# listed. For functions and aliases, the line number of the definition is
# additionally appended to the filename. With -s, only the highest precedence
# type (i.e. the one taking effect) is listed.
# Notes:
#   - This function is similar to 'type -a', however, it does NOT list function
#     and alias bodies (use 'doc' for this), but in turn it lists file names
#     and line numbers for functions and aliases.
#   - Alias definitions are parsed from the .bashrc.* files (see '_get-bashrc').
#     In order to be parsed correctly, alias definitions must only have white-
#     space between the 'alias' keyword and the beginning of the line.
_type() {
  if [[ "$#" -eq 1 ]]; then
    local cmd=$1
  elif [[ "$#" -eq 2 && "$1" = -s ]]; then
    local short=1 cmd=$2
  else
    _print-usage-msg "[-s] <cmd>" >/dev/stderr
    return 1
  fi
  local types=$(type -ta "$cmd")
  if _is-set "$short"; then
    types=$(echo "$types" | head -n 1)
  fi
  local file_i
  echo "$types" | while read t; do
    case "$t" in
      function)
        { shopt -s extdebug; local res=$(declare -F "$cmd"); shopt -u extdebug; }
        local file=$(echo "$res" | cut -d ' ' -f 3-)
        local line=$(echo "$res" | cut -d ' ' -f 2)
        __type-print function "$([[ "$file" =~ ^/ ]] && echo "$file:$line")"
        ;;
      alias)
        __type-print alias "$(grep -nE "^[ ]*alias[ ]+$cmd=" $(_get-bashrc) /dev/null | tail -n 1 | cut -d : -f 1-2)"
        ;;
      file)
        ((file_i++))
        __type-print file "$(which -a "$cmd" | sed -n "${file_i}p")"
        ;;
      builtin)
        __type-print builtin
        ;;
    esac
  done
}
complete -c _type
__type-print() { echo "$1,${2:-null}"; }


#------------------------------------------------------------------------------#
#= Text processing
#------------------------------------------------------------------------------#

# Transform the input to upper-case
# Usage:
#   _to-upper-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-upper-case() {
  _get-input "$@" |
  tr '[:lower:]' '[:upper:]'
}

# Transform the input to lower-case
# Usage:
#   _to-lower-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-lower-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]'
}

# Transform the input to title-case (first letter of each word capitalised).
# Usage:
#   _to-title-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-title-case() {
  _get-input "$@" |
  awk '{
    for (i=1; i<=NF; i++) {
      $i = toupper(substr($i,1,1)) substr($i,2)
    }
  }
  { print }'
}

# Transform the input to kebab-case (lower-case joined by dashes)
# Usage:
#   _to-kebab-case [<args>...]
# If no arguments are provided, the input is read from stdin.
# Notes:
#   - This implementation of kebab-case involves the following:
#     1. All characters are transformed to lower-case
#     2. Punctuation characters (except '-') are deleted
#     3. Whitespace characters are replaced by dashes 
#     4. Repeated dashes replaced with a single dash
#     5. Dashes at the beginning and end of strings are omitted
_to-kebab-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]' |
  tr - ' ' |
  sed 's/[[:punct:]]//g;s/[[:space:]]/-/g' |
  tr -s - |
  sed 's/^-//;s/-$//'
}

# Pad a list of strings up to a desired total length.
# Usage:
#   _pad-left <length> <char> [<args>...]
#   _pad-right <length> <char> [<args>...]
# Example:
#   _pad-left 3 ' ' $(seq 100)
#   _pad-right 8 - red green blue yellow cyan
# In the first of the above examples, the numbers 1 to 100 are padded to the
# left with spaces to a total of 3 digits. In the second examples, the strings
# are padded to the right with dashes to a total width of 8 characters
# Notes:
#   - If no arguments are given beyond <length> and <char>, the strings to pad
#     are read from stdin.
#   - If a string to pad is longer than <length>, it is printed unchanged.
_pad-left() {
  if [[ "$#" -lt 2 ]]; then
    _print-usage-msg "<length> <char> [<args>...]"
    return 1
  fi
  __pad l "$1" "$2" $(shift 2 && _get-input "$@")
}
_pad-right() {
  if [[ "$#" -lt 2 ]]; then
    _print-usage-msg "<length> <char> [<args>...]"
    return 1
  fi
  __pad r "$1" "$2" $(shift 2 && _get-input "$@")
}
__pad() {
  local direction=$1
  local length=$2
  local char=$3
  shift 3
  for e in "$@"; do
    local fill_length=$(("$length"-"${#e}"))
    [[ "$fill_length" -lt 0 ]] && fill_length=0
    local fill=$(printf '%*s' "$fill_length" | tr ' ' "$char")
    case "$direction" in
      l) echo "$fill$e" ;;
      r) echo "$e$fill" ;;
    esac
  done
}

# Prepend line numbers to each line of input
# Usage:
#   _add-line-numbers [-s <sep>] [-u <suffix>] [-r]
# Args:
#   -s <sep>:    separator between line number and input line (default: ' ')
#   -u <suffix>: string to append to each line number (default: '')
#   -r:          right-align line numbers (default: left-align)
_add-line-numbers() {
  # Capture input
  local -r data=$(</dev/stdin)
  local -ir n=$(wc -l <<<"$data")
  # Parse arguments
  local sep=' ' suffix
  local expect_s expect_u align=ln
  for a in "$@"; do
    case "$a" in
      -s) expect_s=1 ;;
      -u) expect_u=1 ;;
      -r) align=rn ;;
      *)
        if _is-set "$expect_s"; then
          sep=$a
          expect_s=
        elif _is-set "$expect_u"; then
          suffix=$a
          expect_u=
        else
          _err "Invalid argument: $a"
          return 1
        fi
    esac
  done
  echo "$data" | nl -s "$sep" -n "$align" -w "$(($(_log10 "$n" -i)+1))" | sed "s/^([ ]*[0-9]+)/\1$suffix/"
}

# Read text from stdin and format it to width of terminal with word wrapping.
# This function is similar to the 'fmt' command, but it preserves all newlines.
# Notes:
#   - awk adds nroff commands to beginning of input (.pl = page length,
#     .ll = line length, .na=disable justification, hy 0 = disable hyphenation)
#   - nroff formats the text
#   - sed reverts the conversion of - to U+2010 (UTF-8 0xE28090) done by nroff
# See https://docstore.mik.ua/orelly/unix3/upt/ch21_03.htm
_wrap() {
  awk -v c=$(tput cols) '
    BEGIN {printf ".pl 1\n.ll %d\n.na\n.hy 0\n", c}
    {print}' |
    nroff |
    sed 's/\xE2\x80\x90/-/g'
}

# Truncate a specific column of a table to a given maximum length
# Usage:
#   _truncate-column <sep> <column> <length> [<mark>]
# Args:
#   <sep>:     column separator regex
#   <column>:  index of column to truncate (indices starting at 1)
#   <length>:  maximum length of column (including truncation mark)
#   [<mark>]:  truncation mark (default: '[...]')
# Description:
#   Reads a table from stdin, truncates the specified column to the given
#   maximum length, and writes the output to stdout.
# Notes:
#   - If an invalid column index is specified, the input table is printed
#     unchanged.
_truncate-column() {
    local -r sep=$1 mark=${4:-[...]}
    local -ir column=$2 length=$3 
    awk -F "$sep" -v COL="$column" -v LEN="$length" -v MARK="$mark" '
      BEGIN {
        OFS = FS
      }
      {
        if (COL >= 1 && COL <= NF) {
          if (length($COL) > LEN)
            $COL = substr($COL, 1, LEN - length(MARK)) MARK
        }
        print $0
      }'
}

#------------------------------------------------------------------------------#
#= Number processing
#------------------------------------------------------------------------------#

# Calculate the logarithm of a given number to a given base
# Usage:
#   log <base> <n> [-i]
# Description:
#   Prints the logarithm of <n> with respect to <base>. If -i is supplied as
#   the last argument, the result rounded to the nearest integer that is lower
#   than the result.
_log() {
  local base=$1 n=$2
  local result=$(bc -l <<<"l($n) / l($base)")
  if [[ "${@: -1}" = -i ]]; then
    _floor "$result"
  else
    echo "$result"
  fi
}

# Calculate the logarithm of two for a given number
# Usage:
#   log2 <n> [-i]
# Description:
#   Prints the logarithm of 2 of <n>. If -i is supplied as the last argument,
#   the result is rounded to the nearest integer that is lower than the result.
_log2() {
  _log 2 "$@"
}

# Calculate the logarithm of ten for a given number
# Usage:
#   log10 <n> [-i]
# Description:
#   Prints the logarithm of 10 of <n>. If -i is supplied as the last argument,
#   the result is rounded to the nearest integer that is lower than the result.
_log10() {
  _log 10 "$@"
}

# Round number ($1) to specific number of digits ($2) after decimal point
_round() {
  printf "%.$2f\n" "$1"
}

# Round number down to nearest integer
_floor() {
  bc <<<"$1/1"
}

#-----------------------------------------------------------------------------#
#= Filename processing
#------------------------------------------------------------------------------#

# Insert string ($2) into filename ($1), just before filename extension.
# Add a suffix to a file basename, just before the extension
# Usage:
#   _insert-basename-suffix <suffix> <file>
# Example:
#   _insert-basename-suffix -foo test.txt  ==>  test-foo.txt
_insert-basename-suffix() {
  local suffix=$1
  local file=$2
  #echo "${file/%.+([^.])/$suffix&}"  # TODO: replace below with this (requires shopt options patsub_replacement for & and extglob for +())
  echo "${file%.*}${suffix}.${file##*.}"
}

# Change the extension of a file name.
# Usage:
#   _change-filename-extension <file> <extension>
# Example:
#   _change-filename-extension test.txt md  ==>  test.md
_change-filename-extension() {
  echo "${1%.*}.$2"
}
