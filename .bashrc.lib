# ~/.bashrc.lib
#
# Shell function library. All functions starting with a single underscore are
# intended to be used by other .bashrc.* files.
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
# Function helpers
#------------------------------------------------------------------------------#

# Print provided args or stdin, if no args are provided.
# Usage:
#   _get-input [<args>...]
# Example:
#   fun() {
#     _get-input "$@" | cmd
#   }
# Notes:
#   - This function is intended to be used inside other functions to gather the
#     input for the enclosing function (see example above). This allows creating
#     functions that take their input either from arguments or from stdin.
#   - If input is taken from arguments, the tokenisation of the argument list
#     is NOT maintained, i.e. the argument list is reproduced as a plain string.
_get-input() {
  [[ "$#" -gt 0 ]] && echo "$*" || echo "$(</dev/stdin)"
}

# Print an error message to stderr.
# Usage:
#   _error <msg>
# The error message includes the name of the function that called this function.
_error() {
  echo "${FUNCNAME[1]}: $@" >&2
}

#------------------------------------------------------------------------------#
# Check OS
#------------------------------------------------------------------------------#

# Check if running on macOS, Linux, or WSL2 (special case of Linux)
_is-mac() {
  [[ "$OSTYPE" =~ darwin ]]
}
_is-linux() {
  [[ "$OSTYPE" =~ linux  ]]
}
_is-wsl() {
  _is-linux && [[ -n "$WSL_DISTRO_NAME" ]]
}

#------------------------------------------------------------------------------#
# Check variables
#------------------------------------------------------------------------------#

# Check if variable is set (i.e. non-empty) or unset (i.e. empty)?
_is-set() {
  [[ -n "$1" ]]
}
_is-unset() {
  [[ -z "$1" ]]
}

#------------------------------------------------------------------------------#
# Check installation status
#------------------------------------------------------------------------------#

# Check whether a given command is installed and in the PATH
_is-installed() {
  which "$1" &>/dev/null
}

# Check whether a given command is installed and in the PATH, or return error
_ensure-installed() {
  if ! _is-installed "$1"; then
    _error "'$1' not installed" && return 1
  fi
}

# Check whether a given Homebrew formula or cask is installed
_is-poured() {
  _ensure-installed brew 
  brew ls --versions "$1" >/dev/null || brew ls --cask --versions "$1" >/dev/null
}

#------------------------------------------------------------------------------#
# Text processing
#------------------------------------------------------------------------------#

# Transform the input to upper-case
# Usage:
#   _upper-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_upper-case() {
  _get-input "$@" |
  tr '[:lower:]' '[:upper:]'
}

# Transform the input to lower-case
# Usage:
#   _lower-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_lower-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]'
}

# Transform the input to title-case (first letter of each word capitalised).
# Usage:
#   _title-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_title-case() {
  _get-input "$@" |
  awk '{
    for (i=1; i<=NF; i++) {
      $i = toupper(substr($i,1,1)) substr($i,2)
    }
  }
  { print }'
}

# Transform the input to kebab-case (lower-case joined by dashes)
# Usage:
#   _kebab-case [<args>...]
# If no arguments are provided, the input is read from stdin.
# Notes:
#   - This implementation of kebab-case involves the following:
#     1. All characters are transformed to lower-case
#     2. Punctuation characters (except '-') are deleted
#     3. Whitespace characters are replaced by dashes 
#     4. Repeated dashes replaced with a single dash
#     5. Dashes at the beginning and end of strings are omitted
_kebab-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]' |
  tr - ' ' |
  sed 's/[[:punct:]]//g;s/[[:space:]]/-/g' |
  tr -s - |
  sed 's/^-//;s/-$//'
}

# Pad a list of strings up to a desired total length.
# Usage:
#   _pad-left <length> <char> [<args>...]
#   _pad-right <length> <char> [<args>...]
# Example:
#   _pad-left 3 ' ' $(seq 100)
#   _pad-right 8 - red green blue yellow cyan
# In the first of the above examples, the numbers 1 to 100 are padded to the
# left with spaces to a total of 3 digits. In the second examples, the strings
# are padded to the right with dashes to a total width of 8 characters
# Notes:
#   - If no arguments are given beyond <length> and <char>, the strings to pad
#     are read from stdin.
#   - If a string to pad is longer than <length>, it is printed unchanged.
_pad-left() {
  [[ "$#" -lt 2 ]] && _error "must provide length and padding character" && return 1
  __pad l "$1" "$2" $(shift 2 && _get-input "$@")
}
_pad-right() {
  [[ "$#" -lt 2 ]] && _error "must provide length and padding character" && return 1
  __pad r "$1" "$2" $(shift 2 && _get-input "$@")
}
__pad() {
  local direction=$1
  local length=$2
  local char=$3
  shift 3
  for e in "$@"; do
    local fill_length=$(("$length"-"${#e}"))
    [[ "$fill_length" -lt 0 ]] && fill_length=0
    local fill=$(printf '%*s' "$fill_length" | tr ' ' "$char")
    case "$direction" in
      l) echo "$fill$e" ;;
      r) echo "$e$fill" ;;
    esac
  done
}

# Read text from stdin and format it to width of terminal with word wrapping.
# This function is similar to the 'fmt' command, but it preserves all newlines.
# Notes:
#   - awk adds nroff commands to beginning of input (.pl = page length,
#     .ll = line length, .na=disable justification, hy 0 = disable hyphenation)
#   - nroff formats the text
#   - sed reverts the conversion of - to U+2010 (UTF-8 0xE28090) done by nroff
# See https://docstore.mik.ua/orelly/unix3/upt/ch21_03.htm
_wrap() {
  awk -v c=$(tput cols) '
    BEGIN {printf ".pl 1\n.ll %d\n.na\n.hy 0\n", c}
    {print}' |
    nroff |
    sed 's/\xE2\x80\x90/-/g'
}

#------------------------------------------------------------------------------#
# Array processing
#------------------------------------------------------------------------------#

# Print the elements of an array with indices (alternative to 'declare -p <a>')
_array-print() {
  [[ "$#" -eq 0 ]] && return
  for i in $(seq "$#"); do
    echo "[$(($i-1))]: ${!i}"
  done
}

# Test if an array contains a specific element.
# Usage:
#   _array-has <array> <element>
# Example:
#   _array-has "${myarr[@]}" foo
_array-has() {
  [[ "$#" -lt 1 ]] && _error "must specify array and element to check for" && return 1
  local array=("${@:1:$#-1}")
  local element=${@:$#}
  for i in "${!array[@]}"; do
    [[ "${array[$i]}" = "$element" ]] && return 0
  done
  return 1
}

# Join the elements of an array with a delimiter.
# Usage:
#   _array-join <array> <delimiter>
# Example:
#   _array-join "${myarr[@]}" ::
# The above example joins the elements of the array with a '::' delimiter.
# A delimiter may be an arbitrary string.
_array-join() {
  [[ "$#" -lt 1 ]] && _error "must specify array and delimiter" && return 1
  local array=("${@:1:$#-1}")
  local d=${@:$#}
  local str="${array[0]}"
  for e in "${array[@]:1}"; do
    str+="$d$e"
  done
  echo "$str"
}

# Remove all occurrences of a specific element from an array.
# Usage:
#   _array-remove <array> <element> <out_array_name>
# Example:
#   _array-remove "${myarr[@]}" foo result
# In the above example, all "foo" elements are removed from the 'myarr' array
# and the resulting array is saved in a variable named 'result'.
# Notes:
#   - The result array DOESN'T need to be declared in the calling function, but
#     it's advisable to declare it with 'local' in order to keep it local.
#   - The assignment to the passed in result array name is implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_array-remove() {
  [[ "$#" -lt 2 ]] && _error "must specify array, element to remove, and name of result variable" && return 1
  local in_array=("${@:1:$#-2}")
  local element=${@:$#-1:1}
  local -n __ref=${@:$#}
  __ref=()
  for i in "${!in_array[@]}"; do
    if [[ "${in_array[$i]}" != "$element" ]]; then
      __ref+=("${in_array[$i]}")
    fi
  done
}

# Split arguments into two arrays separated by a delimiter.
# Usage:
#   _splitargs <array_name_1> <arrary_name_2> <delimiter> <args>...
# Args:
#   <array_name_1>  Name of array variable for elements before delimiter
#   <array_name_2>  Name of array variable for elements after delimiter
#   <delimiter>     Delimiter string 
#   <args>...       Argument sequence containing elements and delimiter
# Example:
#   _splitargs a1 a2 -- foo bar -- baz kux
# The above assigns ["foo" "bar"] to a variable named 'a1' and ["baz" "kux"] to
# a variable named 'a2'. These variables can be used in the calling context.
# Notes:
#   - The variable names DON'T need to be declared in the calling function, but
#     it's advisable to declare them with 'local' in order to keep them local.
#   - If <args>... does not contain the delimiter, then all elements are
#     assigned to <array_name_1> (and <array_name_2> is left empty)
#   - If <args>... contains multiple occurrences of the delimiter, then the
#     split happens at the first of these delimiters.
#   - The passed variable names must not be '__ref1' and '__ref2' as these are
#     internally used (otherwise, a "circular name reference" error occurs).
#   - The assignments to the passed in variable names are implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_splitargs() {
  local -n __ref1=$1 __ref2=$2
  local d=$3
  shift 3
  for i in $(seq "$#"); do
    if [[ "${!i}" = "$d" ]]; then
      __ref1=("${@:1:$(($i-1))}")  # Arguments before delimiter
      __ref2=("${@:$(($i+1))}")    # Arguments after delimiter
      return
    fi
  done
  # If no delimiter found
  __ref1=("$@")
}

#------------------------------------------------------------------------------#
# Filename processing
#------------------------------------------------------------------------------#

# Insert string ($2) into filename ($1), just before filename extension.
# Add a suffix to a file basename, just before the extension
# Usage:
#   _insert-basename-suffix <suffix> <file>
# Example:
#   _insert-basename-suffix -foo test.txt  ==>  test-foo.txt
_insert-basename-suffix() {
  local suffix=$1
  local file=$2
  echo "${file%.*}${suffix}.${file##*.}"
}

# Change the extension of a file name.
# Usage:
#   _change-filename-extension <file> <extension>
# Example:
#   _change-filename-extension test.txt md  ==>  test.md
_change-filename-extension() {
  echo "${1%.*}.$2"
}

#------------------------------------------------------------------------------#
# Terminal colours
#------------------------------------------------------------------------------#

# Print an Select Graphic Rendition (SGR) [1] to set display attributes.
# Usage:
#   _sgr [<colour/modifier>...]
# Available colours:
#   black, black+, red, red+, green, green+, yellow, yellow+, blue, blue+,
#   magenta, magenta+, cyan, cyan+, white, white+
# Available modifiers:
#   x (reset), b (bold), d (dim), i (italic), u (underline)
# Notes:
#   - Colours with a + are the bright versions of the corresponding colours
#   - The x modifier resets all set attributes (colours and modifiers). The
#     same effect can be achieved by omitting any arguments.
#   - Modifiers may be combined into a single argument
# Examples:
#   _sgr red        // Red 
#   _sgr red+       // Bright red 
#   _sgr red b      // Bold red
#   _sgr red biu    // Bold, italic, and underlined red
#   _sgr red b i u  // Same as above
#   _sgr bu         // Bold and underlined (colour isn't changed)
#   _sgr x          // Reset all previously set attributes
#   _sgr            // Same as above
#   echo "$(_sgr red bi)red $(_sgr x blue+ u)blue$(_sgr) normal"
# [1] https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
_sgr() {
  local p
  for a in "$@"; do
    # Parse colour
    case "$a" in
      black)    p+=(30); continue ;;
      red)      p+=(31); continue ;;
      green)    p+=(32); continue ;;
      yellow)   p+=(33); continue ;;
      blue)     p+=(34); continue ;;
      magenta)  p+=(35); continue ;;
      cyan)     p+=(36); continue ;;
      white)    p+=(37); continue ;;
      black+)   p+=(90); continue ;;
      red+)     p+=(91); continue ;;
      green+)   p+=(92); continue ;;
      yellow+)  p+=(93); continue ;;
      blue+)    p+=(94); continue ;;
      magenta+) p+=(95); continue ;;
      cyan+)    p+=(96); continue ;;
      white+)   p+=(97); continue ;;
    esac
    # Parse modifiers (x, b, i, u, d)
    a=($(grep -o . <<<"$a"))
    for i in "${a[@]}"; do
      case "$i" in
        x) p+=(0) ;;  # Reset
        b) p+=(1) ;;  # Bold
        d) p+=(2) ;;  # Dim
        i) p+=(3) ;;  # Italic
        u) p+=(4) ;;  # Underlined
      esac
    done
  done
  # Print escape sequence
  printf "\e[$(tr ' ' ';' <<<"${p[@]}")m"
}
