# ~/.bashrc.lib


# Check for macOS, Linux, or WSL2
_is-mac()   { [[ "$OSTYPE" =~ darwin ]]; }
_is-linux() { [[ "$OSTYPE" =~ linux  ]]; }
_is-wsl() { _is-linux && [[ -n "$WSL_DISTRO_NAME" ]]; }

# Is variable set (non-empty) or unset (empty)?
_is-set()   { [[ -n "$1" ]]; }
_is-unset() { [[ -z "$1" ]]; }

# Check whether a given command is installed
_is-installed() { which "$1" &>/dev/null; }

# Ensure that a given command is installed or print an error message otherwise
_ensure-installed() { _is-installed "$1" || { echo "Error: '$1' not installed."; return 1; }; }


# Convert lower-case to upper-case. Read input from arg list or stdin.
_to-upper() { (($# == 0)) && __to-upper || __to-upper <<<"$@"; }
__to-upper() { tr '[:lower:]' '[:upper:]'; }

# Convert upper-case to lower-case. Read input from arg list or stdin.
_to-lower() { (($# == 0)) && __to-lower || __to-lower <<<"$@"; }
__to-lower() { tr '[:upper:]' '[:lower:]'; }


# Pad args ($2...) with 0s to number of digits ($1). Read from arg list or stdin.
_pad() {
  (($# == 0)) && return 1
  (($# == 1)) && __pad "$1" $(</dev/stdin) || __pad $@
}
__pad() { printf "%0$1d\n" ${@:2}; }

# Insert string ($2) into filename ($1), just before filename extension.
_insert() {
  local file=$1; local str=$2
  echo "${file%.*}${str}.${file##*.}"
}

# Read text from stdin and format it to width of terminal with word wrapping.
# This function is similar to the 'fmt' command, but it preserves all newlines.
_format() {
  awk -v c=$(tput cols) 'BEGIN{printf ".pl 1\n.ll %d\n.na\n.hy 0\n", c}{print}' |
    nroff |
    sed 's/\xE2\x80\x90/-/g'
  # - awk adds nroff commands to beginning of input (.pl = page length,
  #   .ll = line length, .na=disable justification, hy 0 = disable hyphenation)
  # - nroff formats the text
  # - sed reverts the conversion of - to U+2010 (UTF-8 0xE28090) done by nroff
  # https://docstore.mik.ua/orelly/unix3/upt/ch21_03.htm
}


# Split an args sequence at a custom delimiter into two arrays, one containing
# the args before the delimiter and one containing the args after the delimiter.
# Usage:
#   _splitargs <arr_a> <arr_b> <delim> <args>...
# Args:
#   <arr_a>  Name of an array to which to assign the args before the delimiter
#   <arr_b>  Name of an array to which to assign the args after the delimiter
#   <delim>  The delimiter (e.g. --)
#   <args>   Sequence of arguments (possibly containing)
# Example usage:
#   _splitargs arr1 arr2 -- before1 before2 -- after1 after2
# The above results in the following assignments to arr1 and arr2:
#   - arr1["before1", "before2"]
#   - arr2["after1", "after2"]
# If the args sequence does not contain the delimiter, then all the args are
# assigned to the first array (<arr_a>).
# CAUTION: the passed in array names must not be __a and __b as these are the
# locally used array names (causes a "circular name reference" error).
_splitargs() {
  # Nameref variables, see [1]
  # [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
  local -n __a=$1 __b=$2
  local delim=$3
  shift 3
  for i in $(seq 1 "$#"); do
    if [[ "${!i}" = "$delim" ]]; then
      __a=("${@:1:$(($i-1))}")  # Args before delimiter
      __b=("${@:$(($i+1))}")    # Args after delimiter
      return
    fi
  done
  __a=("$@")  # If the args don't contain the delimiter
}

# Test if an array contains a specific element.
# Usage example: _has "${myarr[@]}" foo
_has() {
  local array=("${@:1:$#-1}")
  local element=${@:$#}
  for i in $(seq 0 $(("${#array[@]}"-1))); do
    [[ "${array[$i]}" = "$element" ]] && return 0
  done
  return 1
}


# Print an ANSI Select Graphic Rendition (SGR) escape sequence (see [1])
#
# Usage:
#   _c [<arg>]...
# Where <arg> is either a colour, or one or multiple modifiers.
#
# Colours:
#   - black
#   - red
#   - green
#   - yellow
#   - blue
#   - magenta
#   - cyan
#   - white
# A plus sign may be appended to each colour (e.g. 'red+'), in which case the
# bright version of the colour is used.
#
# Modifiers:
#   - x: reset
#   - b: bold
#   - d: dim
#   - i: italic
#   - u: underline
# The x modifier is special as it resets all the previously set attributes
# (colours and modifiers). Multiple modifiers can be combined in a single arg.
#
# Example usage:
#   -c red        // Red 
#   -c red+       // Bright red 
#   -c red b      // Red, bold
#   -c red biu    // Red, bold, italic, and underlined
#   -c red b i u  // Equivalent to above command
#   -c            // Reset all previously set colours and modifiers
#   -c x          // Equivalent to above command
#   -c bu         // Bold and underlined (don't change colour)
#
# Application:
#   echo "$(c red bi)red $(c x blue+ u)blue$(c) normal"
#
# [1] https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
_c() {
  local p
  for a in "$@"; do
    # Parse colour
    case "$a" in
      black)    p+=(30); continue ;;
      red)      p+=(31); continue ;;
      green)    p+=(32); continue ;;
      yellow)   p+=(33); continue ;;
      blue)     p+=(34); continue ;;
      magenta)  p+=(35); continue ;;
      cyan)     p+=(36); continue ;;
      white)    p+=(37); continue ;;
      black+)   p+=(90); continue ;;
      red+)     p+=(91); continue ;;
      green+)   p+=(92); continue ;;
      yellow+)  p+=(93); continue ;;
      blue+)    p+=(94); continue ;;
      magenta+) p+=(95); continue ;;
      cyan+)    p+=(96); continue ;;
      white+)   p+=(97); continue ;;
    esac
    # Parse modifiers (x, b, i, u, d)
    a=($(grep -o . <<<"$a"))
    for i in "${a[@]}"; do
      case "$i" in
        x) p+=(0) ;;  # Reset
        b) p+=(1) ;;  # Bold
        d) p+=(2) ;;  # Dim
        i) p+=(3) ;;  # Italic
        u) p+=(4) ;;  # Underlined
      esac
    done
  done
  # Print escape sequence
  printf "\e[$(tr ' ' ';' <<<"${p[@]}")m"
}


if _is-installed brew; then
  _is-installed-homebrew() {
    brew ls --versions "$1" >/dev/null || brew ls --cask --versions "$1" >/dev/null
  }
fi
