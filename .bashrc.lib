# ~/.bashrc.lib
#
# Shell function library. All functions starting with a single underscore are
# intended to be used by other .bashrc.* files.
#------------------------------------------------------------------------------#

#=-----------------------------------------------------------------------------#
# Function helpers
#------------------------------------------------------------------------------#

# If no arguments are provided, print stdin, else print the arguments.
# Usage:
#   _get-input [<args>...]
# This function can be used within another function to gather the function's
# input either from the arguments or from stdin.
# Notes:
#   - The tokenisation of the argument list is NOT maintained, that means, the
#     arguments are printed as a single string.
_get-input() {
  if [[ "$#" -gt 0 ]]
    then echo "$*"
  else
    echo "$(</dev/stdin)"
  fi
}

#=-----------------------------------------------------------------------------#
# Output functions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions print output intended to be processed or used by other
# functions or commands.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Print ~/.bashrc.* files in the order they are sourced by ~/.bashrc
_get-bashrc() {
  echo ~/.bashrc.path ~/.bashrc.lib ~/.bashrc.main ~/.bashrc.!(path|lib|main)
}

# List and filter variables
# Usage:
#   _list-vars [-nNvV <pat>] [-tT <attr>] [-l <len>] [-fs] [-c <cols>]
# Args:
#   -n|N <pat>:  postive/negative variable name filter
#   -v|V <pat>:  positive/negative variable value filter
#   -t|T <attr>: positive/negative attribute filter
#   -l <len>:    maximum length of printed variable values (default: 100)
#   -f:          print the full variable values (up to 2000 characters)
#   -s:          print only the variable names
#   -c <cols>:   columns to print (default: 1,2,3,4)
# Description:
#   Prints the variables matching the provided filters as a table consisting of
#   the following columns:
#     - 1: row number
#     - 2: attributes
#     - 3: variable name
#     - 4: variable value
#   The set of columns to print may be customised with the -c option. The -s
#   option is a shorthand for '-c 3' and prints only the variable names.
# Notes:
#   1. Lower-case options -n, -v, and -t allow specifying POSITIVE patterns.
#      For example '-n ^foo' selects all variables whose name starts with 'foo'.
#   2. Upper-case options -N, -V, and -T allow specifying NEGATIVE patterns.
#      For example, '-N ^foo' selects all variables whose name does NOT start
#      with 'foo'.
#   3. Multiple occurrences of the same lower-case options -n, -v, and -t are
#      conjoined with OR. For example, '-n ^foo -n ^bar' selects all variables
#      whose starts with 'foo' OR starts with 'bar'.
#   4. Multiple occurrences of the same upper-case options -N, -V, and -T are
#      conjoined wih AND. For example '-N ^foo -N ^bar' selects all variables
#      whose does NOT start with 'foo' AND does NOT start with 'bar'.
#   5. Different types of options (i.e. -n, -N, -v, -V, -t, and -T among each
#      other) are conjoined with AND. For example, '-n ^foo -t a' selects all
#      variables whose name starts with 'foo' AND have the 'a' attribute.
#   6. The above also hold for upper-case options. For example, '-n ^foo -N _'
#      selects all variables whose name starts with 'foo' AND whose name does
#      NOT contain an underline. As another example, '-n ^foo -T a' selects all
#      variables whose name starts with 'foo' AND do NOT have the 'a' attribute.
#   7. <pat> may be any pattern understood by AWK. Certain characters, such as
#      '(' and ')' must be escaped to not be interpreted by AWK.
#   8. In <attr>, the absence of any attribute can be specified with '-'.
#   9. Text variable values are printed with enclosing "...". Array variable 
#      values are printed with enclosing (...). These enclosing characters
#      must be taken into account when creating patterns with -v and -V.
#  10. The -l option is capped at 2000 characters. Similarly, the -f option
#      also truncates the variable values at 2000 characters. This limitation
#      is due to the maximum line length limit of 2048 characters of 'column'
#      which is used to format the output table.
#  11. The output rows are sorted alphabetically by variable name. This holds
#      even if the variable name column (column 3) is not printed.
_list-vars() {
  # Capture variables and add line numbers (indices) as first column
  local -r data=$(
    declare -p |
      awk '
        BEGIN {
          i = 1
        }
        {
          attr = $2
          gsub(/--/, "+", attr)
          gsub(/-/, "", attr)
          gsub(/+/, "-", attr)
          match($3, /^[^=]+/)
          name = substr($3, RSTART, RLENGTH)
          match($0, /=.*$/)
          value = substr($0, RSTART+1, RLENGTH)
          print i "\t" attr "\t" name "\t" value
          i++
        }'
    )
  # Parse command-line arguments
  local -a pat_names_arr pat_names_i_arr pat_values_arr pat_values_i_arr attr_arr attr_i_arr columns=(1 2 3 4)
  local -i max_value_len=100
  local expect_n expect_N expect_v expect_V expect_t expect_T expect_l expect_c
  local a
  for a in "$@"; do
    case "$a" in
      -n) expect_n=1 ;;
      -N) expect_N=1 ;;
      -v) expect_v=1 ;;
      -V) expect_V=1 ;;
      -t) expect_t=1 ;;
      -T) expect_T=1 ;;
      -f) max_value_len=2000 ;;
      -l) expect_l=1 ;;
      -s) columns=(3) ;;
      -c) expect_c=1 ;;
      *)
        if _is-set "$expect_n"; then
          pat_names_arr+=("$a")
          expect_n=
        elif _is-set "$expect_N"; then
          pat_names_i_arr+=("$a")
          expect_N=
        elif _is-set "$expect_v"; then
          pat_values_arr+=("$a")
          expect_v=
        elif _is-set "$expect_V"; then
          pat_values_i_arr+=("$a")
          expect_V=
        elif _is-set "$expect_t"; then
          local attr=$(_parse-attributes "$a" '.*')
          _is-set "$attr" && attr_arr+=(".*$attr.*")
          expect_t=
        elif _is-set "$expect_T"; then
          local attr=$(_parse-attributes "$a" '.*')
          _is-set "$attr" && attr_i_arr+=(".*$attr.*")
          expect_T=
        elif _is-set "$expect_l"; then
          max_value_len=$([[ "$a" -gt 2000 ]] && echo 2000 || echo "$a")
          expect_l=
        elif _is-set "$expect_c"; then
          columns=($(echo "$a" | tr , '\n' | sort -u | sed -n '/^[1-4]$/p'))
          expect_c=
        else
          _print-error-msg "Invalid option: $a"
          return  1
        fi
    esac
  done
  # Filter variables
  # Note: the reason that only indices are used is that 'comm' has a line
  # length limit of ~6000 characters
  local indices=$(cut -f 1 <<<"$data")
  [[ "${#attr_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter "$data" attr_arr 2 "$indices")
  [[ "${#attr_i_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter-inverted "$data" attr_i_arr 2 "$indices")
  [[ "${#pat_names_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter "$data" pat_names_arr 3 "$indices")
  [[ "${#pat_names_i_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter-inverted "$data" pat_names_i_arr 3 "$indices")
  [[ "${#pat_values_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter "$data" pat_values_arr 4 "$indices")
  [[ "${#pat_values_i_arr[@]}" -gt 0 ]] &&
    indices=$(__list-vars-filter-inverted "$data" pat_values_i_arr 4 "$indices")
  echo "$data" |
    sed -n "$(for i in $indices; do echo "${i}p;"; done)" |
    awk -F '\t' -v M="$max_value_len" '{if (length($4)>M) $4=substr($4, 1, M-5)"[...]"; print $2"\t"$3"\t"$4}' |
    nl -n ln -w "$(($(_log10 $(wc -l <<<"$indices") -i)+1))" |
    cut -f "$(_array-join "${columns[@]}" ,)" |
    column -t -s $'\t'
}

# Get indices of vars matching any of given patterns AND given set of indices
__list-vars-filter() {
  local -r __data=$1 __indices=$4
  local -nr __patterns=$2
  local -ir __field=$3
  local __p __new_matches
  for __p in "${__patterns[@]}"; do
    __new_matches+=$'\n'$(echo "$__data" | awk -F '\t' '$'"$__field"' ~ /'"$__p"'/ {print $1}')
  done
  comm -12 <(echo "$__indices" | sort) <(echo "$__new_matches" | sed '/^$/d' | sort -u)
}

# Get indices of vars NOT matching given patterns AND matching given indices
__list-vars-filter-inverted() {
  local -r __data=$1
  local -nr __patterns=$2
  local -ir __field=$3
  local __indices=$4
  local __p
  for __p in "${__patterns[@]}"; do
    __indices=$(comm -12 <(echo "$__indices" | sort) <(echo "$__data" | awk -F '\t' '$'"$__field"' !~ /'"$__p"'/ {print $1}' | sort -u))
  done
  echo "$__indices"
}

# Print value of a variable (for arrays, print array)
_get-var-value() {
  :
}

# Print the attributes of a variable
# Usage:
#   _get-attributes <var-name> [-s]
# Args:
#   <var-name>: name of a variable
#   -s:         print only attribute names without descriptions
# Notes:
#   - If the variable has no attributes, the output is empty
#   - If <var-name> is not a variable, an error is returned
_get-attributes() {
  _ensure-variable "$1" || return 1
  local -n __ref=$1
  _describe-attributes "${__ref@a}" "$2"
}

# Print variable attributes
# Usage:
#   _describe-attributes [<attr-str>] [-s]
# Args:
#   <attr-str>: a string of one or more attributes (examples: 'a', 'iAau')
#   -s:         print only attribute names without descriptions
# Notes:
#   - If <attr-str> is omitted, all attributes are printed
#   - For the full list and description of attributes, see 'declare' [1]
# References:
#   [1] https://www.gnu.org/software/bash/manual/bash.html#index-declare
# TODO: make default option print all attributes on one line without spaces
_describe-attributes() {
  [[ "${@: -1}" = -s ]] && local short=1
  local data=$(cat <<EOF
A (associative array)
a (indexed array)
i (integer)
l (lower case)
n (name reference)
r (read-only)
t (trace)
u (upper case)
x (export)
EOF
  )
  # Print all attributes
  if [[ "$#" -eq 0 || ("$#" -eq 1 && "$1" = -s) ]]; then
    echo "$data"
  # Print only specified attributes
  else
    local -a attributes=($(_parse-attributes "$1" ' '))
    local a
    for a in "${attributes[@]}"; do
      echo "$data" | sed -n "/^$a /p"
    done
  fi |
  # Format as short or normal output based on -s option
  if _is-set "$short"; then
    cut -c 1
  else
    cat
  fi
}

# Parse a variable attribute specification
# Usage:
#   _parse-attributes <attr> [<sep>]
# Args:
#   <attr>:  a set of one or more attributes (e.g. 'i', 'ir')
#   <sep>:   separator between attributes in the output (default: "")
# Description:
#   Prints all valid attributes in the input in alphabetical order, discarding
#   any repeated and invalid attributes.
# Notes:
#   - Returns 1 if the output is empty (i.e. if there was no valid attribute
#     in the input).
#   - The separator may be a string of any length and may include characters
#     such as '\t' or '\n'.
_parse-attributes() {
  local -r attr=$1 sep=${2}
  echo "$attr" | sed "s/[^Aailnrtux-]//g" | grep -o . | sort -u | paste -s -d ' ' - | sed 's/ /'"$sep"'/g'
}

# Print a Select Graphic Rendition (SGR) code.
# Usage:
#   _sgr [<keyword>...]
# The available keywords are:
#    1. red[+]
#    2. green[+]
#    3. yellow[+]
#    4. blue[+]
#    5. magenta[+]
#    6. cyan[+]
#    7. white[+]
#    8. black[+]
#    9. bold
#   10. italic
#   11. dim
#   12. underline
#   13. reset
# The 8 colours without an appended + are the normal versions of these colours
# and appending a + means selecting the bright version of this colour. There
# may be any number of keywords and they may be in any order. However, the
# corresponding attributes are applied sequentially and a later keyword may
# override the effect of a previous keyword. For example 'red italic green'
# results in 'italic' and 'green' being select (the effect of 'red' is undone
# by the appearance of 'green' later in the list).
# Notes:
#   - The 'reset' keyword resets all previously specified attributes.
#   - If no keywords are specified, it has the same effect as specifying 'reset'
#     as the only or last keyword.
# Example:
#   echo "$(_sgr bold red)This is bold red. $(_sgr)This is normal."
# References:
#   - https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
_sgr() {
  local -a params
  local a
  for a in $@; do
    case "$a" in
      # Normal colours
      black)      params+=(30) ;;
      red)        params+=(31) ;;
      green)      params+=(32) ;;
      yellow)     params+=(33) ;;
      blue)       params+=(34) ;;
      magenta)    params+=(35) ;;
      cyan)       params+=(36) ;;
      white)      params+=(37) ;;
      # Bright colours
      black+)     params+=(90) ;;
      red+)       params+=(91) ;;
      green+)     params+=(92) ;;
      yellow+)    params+=(93) ;;
      blue+)      params+=(94) ;;
      magenta+)   params+=(95) ;;
      cyan+)      params+=(96) ;;
      white+)     params+=(97) ;;
      # Modifiers
      bold)       params+=(1) ;;
      dim)        params+=(2) ;;
      italic)     params+=(3) ;;
      underlined) params+=(4) ;;
      reset)      params+=(0) ;;
    esac
  done
  local IFS=';'
  printf "\e[${params[*]}m"
}

#=-----------------------------------------------------------------------------#
# User message functions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions print user-facing output messages.
#
# CAUTION: these functions are intended to be used in other functions.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Print an error message to stderr.
# Usage:
#   _print-error-msg <msg>... [-- <func-stack-index>]
# The output is highlighed with Select Graphic Rendition (SGR) codes if stderr
# is directed to the terminal. The <func-stack-index> argument is the index in
# the function call stack of the function name to print. Its default value is
# 1, which corresponds to the immediate caller of _print-error-msg.
# Notes:
#   - <msg> may include 'echo -e' escape codes such as '\n' and '\t'
_print-error-msg() {
  local -a msg_arr index_arr
  _splitargs msg_arr index_arr -- "$@"
  _cond-sgr-msg red bold -- \
    "${FUNCNAME["${index_arr[0]:-1}"]:-<unknown>}: ${msg_arr[@]}\n" -- \
    2
}

# Print usage message for a function to stderr.
# Usage:
#   _print-usage-msg <msg>... [-- <func-stack-index>]
# The output is highlighed with Select Graphic Rendition (SGR) codes if stderr
# is directed to the terminal. The <func-stack-index> argument is the index in
# the function call stack of the function name to print. Its default value is
# 1, which corresponds to the immediate caller of _print-usage-msg.
# Notes:
#   - <msg> may include 'echo -e' escape codes such as '\n' and '\t'
_print-usage-msg() {
  local msg_arr index_arr
  _splitargs msg_arr index_arr -- "$@"
  _cond-sgr-msg cyan bold -- \
    "Usage:\n  ${FUNCNAME["${index_arr[0]:-1}"]:-<unknown>} ${msg_arr[@]}\n" -- \
    2
}

#=-----------------------------------------------------------------------------#
# Conditional functions
#------------------------------------------------------------------------------#

# Print a message if file descriptor is directed to terminal.
# Usage:
#   _cond <msg>... [-- <fd>]
# The default value for <fd> is 1, which corresponds to stdout. That means, the
# function prints the message to stdout IF stdout is directed to the terminal.
# To use stderr instead, append the delimiter -- followed by 2 to the argument
# list. In that case, the message is written to stderr IF stderr is directed
# to the terminal.
# Notes:
#   - The message is printed without an implicit newline at the end.
#   - All escape codes understood by 'echo -e' (such as '\n' or '\t') may be
#     included in the message.
_cond() {
  local msg_arr fd_arr
  _splitargs msg_arr fd_arr -- "$@"
  local fd=${fd_arr[0]:-1}
  _ensure-file-descriptor "$fd" || return 1
  if [[ -t "$fd" ]]; then
    echo -ne "${msg_arr[@]}" >&"$fd"
  fi
}

# Print an SGR code if file descriptor is directed to terminal.
# Usage:
#   _cond-sgr <sgr-arg>... [-- <fd>]
_cond-sgr() {
  local -a sgr_arr fd_arr
  _splitargs sgr_arr fd_arr -- "$@"
  local fd=${fd_arr[0]:-1}
  _ensure-file-descriptor "$fd" || return 1
  if [[ -t "$fd" ]]; then
    _sgr "${sgr_arr[@]}" >&"$fd"
  fi
}

# Print an SGR-formatted message if file descriptor is directed to terminal.
# Usage:
#   _cond-sgr-msg <sgr-arg>... -- <msg>... [-- <fd>]
_cond-sgr-msg() {
  local -a sgr_arr msg_fd_arr msg_arr fd_arr
  _splitargs sgr_arr msg_fd_arr -- "$@"
  _splitargs msg_arr fd_arr -- "${msg_fd_arr[@]}"
  local fd=${fd_arr[0]:-1}
  _ensure-file-descriptor "$fd" || return 1
  local msg="${msg_arr[@]}"
  if [[ -t "$fd" ]]; then
    msg="$(_sgr "${sgr_arr[@]}")${msg}$(_sgr)"
  fi
  echo -ne "$msg" >&"$fd"
}

#=-----------------------------------------------------------------------------#
# Predicate funtions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions check a condition and return either 0 (true) or 1 (false).
#
# Usage example:
#
#   if _is-XXX; then
#     ...
#   fi
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Check whether running on macOS
_is-mac() {
  [[ "$OSTYPE" =~ darwin ]]
}

# Check whether running on Linux
_is-linux() {
  [[ "$OSTYPE" =~ linux  ]]
}

# Check whether running on a WSL distribution of Linux
# References:
#   - https://learn.microsoft.com/en-us/windows/wsl/install
#   - https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux
_is-wsl() {
  _is-linux && [[ -n "$WSL_DISTRO_NAME" ]]
}

# Check whether the provided value is set (i.e. non-empty)
# Notes:
#   - Returns 1 (false) if no value is provided.
_is-set() {
  [[ -n "$1" ]]
}

# Check whether the provided value is empty (or non-existent)
# Notes:
#   - Returns 0 (true) if no value is provided.
_is-empty() {
  [[ -z "$1" ]]
}

# Check whether a number is even
_is-even() {
  (($1 % 2 == 0))
}

# Check whether a number is odd
_is-odd() {
  (($1 % 2 != 0))
}

# Check whether the variable with the provided name is set (i.e. non-empty)
# Notes:
#   - Returns 1 (false) if no variable with the provided name exists.
_has-value() {
  _is-var-name "$1" || return 1
  local -n __ref=$1
  _is-set "$__ref"
}

# Check whether there is a variable with the provided name
_is-variable() {
  declare -p -- "$1" &>/dev/null
}

# TODO: combine with *-any-of() function and define 'aiu' as AND and 'a' 'i' 'u'
#       as OR. This allows combinations of AND and OR. Check how easy it is to
#       implement this.
# TODO: introduce - as a special attribute to mean "no attributes"
# Check whether a variable has all of the specified attributes
# Usage:
#   _has-attributes <var-name> <attr-str>...
# Args:
#   <var-name>: name of a variable
#   <attr-str>: a string of one or more attributes (examples: 'a', 'iAau')
# Notes:
#   - The values of all <attr-str> are concatenated to a unified input, i.e.,
#     'a' 'i' 'u' is the same as 'aiu'
#   - If the attribute input is empty, 1 is returned
_has-attributes() {
  #_ensure-variable "$1" || return 1
  local -n __ref=$1
  shift
  local -a __input
  # If input is empty or contains invalid attributes, return 1
  __input=($(_parse-attributes "$@" ' ')) || return 1
  local __i
  for __i in "${__input[@]}"; do
    [[ "${__ref@a}" =~ "$__i" ]] || return 1
  done
}
complete -v _has-attributes

# TODO: introduce - as a special attribute to mean "no attributes"
# Check whether a variable has any of the specified attributes
# Usage:
#   _has-attributes-any-of <var-name> <attr-str>...
# Args:
#   <var-name>: name of a variable
#   <attr-str>: a string of one or more attributes (examples: 'a', 'iAau')
# Notes:
#   - The values of all <attr-str> are concatenated to a unified input, i.e.,
#     'a' 'i' 'u' is the same as 'aiu'
#   - If the attribute input is empty, 1 is returned
_has-attributes-any-of() {
  _ensure-variable "$1" || return 1
  local -n __ref=$1
  shift
  local __a
  for __a in $(_parse-attributes "$@" ' '); do
    [[ "${__ref@a}" =~ "$__a" ]] && return 0
  done
  return 1
}
complete -v _has-attributes-any-of

# Check whether a variable is an indexed array
# Usage:
#   _is-indexed-array <var-name>
_is-indexed-array() {
  _has-attributes "$1" a
}

# Check whether a variable is an associative array
# Usage:
#   _is-associative-array <var-name>
_is-associative-array() {
  _ensure-variable "$1" || return 1
  _has-attributes "$1" A
}

# Check whether a variable is either an indexed or an associative array 
# Usage:
#   _is-array <var-name>
_is-array() {
  _ensure-variable "$1" || return 1
  _has-attributes-any-of "$1" Aa
}

# Check whether a variable is read-only
# Usage:
#   _is-read-only <var-name>
_is-read-only() {
  _ensure-variable "$1" || return 1
  _has-attributes "$1" r
}

# Check whether the argument is the name of a shell function
_is-function() {
  [[ "$(type -t "$1")" = function ]]
}
complete -A function _is-function

# Check whether a given command is a shell alias
_is-alias() {
  [[ "$(type -t "$1")" = alias ]]
}
complete -a _is-alias

# Check whether a given command is a shell builtin
_is-builtin() {
  [[ "$(type -t "$1")" = builtin ]]
}
complete -b _is-builtin

# Check whether a given command is an executable file in the PATH
_is-exec-file() {
  [[ "$(type -t "$1")" = file ]]
}
complete -c _is-exec-file

# Check whether a given command exists (i.e. is either an executable file in 
# the path, an alias, a function, or a shell builtin)
_is-cmd() {
  _is-exec-file "$1" || _is-alias "$1" || _is-function "$1" || _is-builtin "$1"
}
complete -c _is-cmd

# Check whether a given Homebrew formula or cask is installed
# Note: also checks whether Homebrew is installed, and aborts otherwise
_is-homebrew-poured() {
  _ensure-installed brew || return 1
  brew ls --versions "$1" >/dev/null || brew ls --cask --versions "$1" >/dev/null
}

#=-----------------------------------------------------------------------------#
# Enforcement funtions
#------------------------------------------------------------------------------#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #
# These functions enforce a specific condition by printing an error message
# and returning 1, if the condition is not met.
#
# CAUTION: these functions are intended to be used in other functions.
#
# Example usage (in other function):
#   
#   _ensure-XXX || return 1
# 
# In the above example, the function aborts if the condition is not met.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #

# Ensure that the argument is a valid command.
_ensure-installed() {
  if ! _is-cmd "$1"; then
    _print-error-msg "'$1' is not installed" -- 2
    return 1
  fi
}

# Ensure that argument is a valid file descriptor.
# Note: the list of accepted file descriptors is hardcoded to 0, 1, and 3.
_ensure-file-descriptor() {
  if [[ ! "$1" =~ 0|1|2 ]]; then
    _print-error-msg "'$1' is not a valid file descriptor" -- 2 
    return 1
  fi
}

_ensure-array() {
  if ! _is-array "$1"; then
    _print-error-msg "'$1' is not an array" -- 2 
    return 1
  fi
}

# Ensure that exactly one argument is given.
# Usage:
#   _ensure-argc-1 <argc> <usage-msg>...
_ensure-argc-1() {
  local argc=$1
  shift
  if [[ "$argc" -ne 1 ]]; then
    _print-usage-msg "$@" -- 2
    return 1
  fi
}

# Ensure that the argument is a valid variable name.
_ensure-var-name() {
  if ! _is-var-name "$1"; then
    _print-error-msg "'$1' is not a valid variable name" -- 2 
    return 1
  fi
}

# Ensure that the provided NAME is a declared variable
_ensure-variable() {
  if ! _is-variable "$1"; then
    _print-error-msg "'$1' is not a variable" -- 2
    return 1
  fi
}

# TODO: change to _is-identifier()
# Check whether the argument is a valid variable name.
# Usage:
#   _is-var-name <name>
# Note: this function just checks whether the name adheres to the naming
# restrictions, not whether a variable with that name is declared or assigned.
_is-var-name() {
  [[ "$1" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]
}




#=-----------------------------------------------------------------------------#
# Miscellaneous functions
#------------------------------------------------------------------------------#

# List all the types of a command.
# Usage:
#   _type [-s] <cmd>
# Lists all the types (function, alias, file, or builtin) for <cmd> in order
# of precedence. For files, functions, and aliases, the source file is also
# listed. For functions and aliases, the line number of the definition is
# additionally appended to the filename. With -s, only the highest precedence
# type (i.e. the one taking effect) is listed.
# Notes:
#   - This function is similar to 'type -a', however, it does NOT list function
#     and alias bodies (use 'doc' for this), but in turn it lists file names
#     and line numbers for functions and aliases.
#   - Alias definitions are parsed from the .bashrc.* files (see '_get-bashrc').
#     In order to be parsed correctly, alias definitions must only have white-
#     space between the 'alias' keyword and the beginning of the line.
_type() {
  if [[ "$#" -eq 1 ]]; then
    local cmd=$1
  elif [[ "$#" -eq 2 && "$1" = -s ]]; then
    local short=1 cmd=$2
  else
    _print-usage-msg "[-s] <cmd>" >/dev/stderr
    return 1
  fi
  local types=$(type -ta "$cmd")
  if _is-set "$short"; then
    types=$(echo "$types" | head -n 1)
  fi
  local file_i
  echo "$types" | while read t; do
    case "$t" in
      function)
        { shopt -s extdebug; local res=$(declare -F "$cmd"); shopt -u extdebug; }
        local file=$(echo "$res" | cut -d ' ' -f 3-)
        local line=$(echo "$res" | cut -d ' ' -f 2)
        __type-print function "$([[ "$file" =~ ^/ ]] && echo "$file:$line")"
        ;;
      alias)
        __type-print alias "$(grep -nE "^[ ]*alias[ ]+$cmd=" $(_get-bashrc) /dev/null | tail -n 1 | cut -d : -f 1-2)"
        ;;
      file)
        ((file_i++))
        __type-print file "$(which -a "$cmd" | sed -n "${file_i}p")"
        ;;
      builtin)
        __type-print builtin
        ;;
    esac
  done
}
complete -c _type
__type-print() { echo "$1,${2:-null}"; }


#=-----------------------------------------------------------------------------#
# Text processing
#------------------------------------------------------------------------------#

# Transform the input to upper-case
# Usage:
#   _to-upper-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-upper-case() {
  _get-input "$@" |
  tr '[:lower:]' '[:upper:]'
}

# Transform the input to lower-case
# Usage:
#   _to-lower-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-lower-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]'
}

# Transform the input to title-case (first letter of each word capitalised).
# Usage:
#   _to-title-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-title-case() {
  _get-input "$@" |
  awk '{
    for (i=1; i<=NF; i++) {
      $i = toupper(substr($i,1,1)) substr($i,2)
    }
  }
  { print }'
}

# Transform the input to kebab-case (lower-case joined by dashes)
# Usage:
#   _to-kebab-case [<args>...]
# If no arguments are provided, the input is read from stdin.
# Notes:
#   - This implementation of kebab-case involves the following:
#     1. All characters are transformed to lower-case
#     2. Punctuation characters (except '-') are deleted
#     3. Whitespace characters are replaced by dashes 
#     4. Repeated dashes replaced with a single dash
#     5. Dashes at the beginning and end of strings are omitted
_to-kebab-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]' |
  tr - ' ' |
  sed 's/[[:punct:]]//g;s/[[:space:]]/-/g' |
  tr -s - |
  sed 's/^-//;s/-$//'
}

# Pad a list of strings up to a desired total length.
# Usage:
#   _pad-left <length> <char> [<args>...]
#   _pad-right <length> <char> [<args>...]
# Example:
#   _pad-left 3 ' ' $(seq 100)
#   _pad-right 8 - red green blue yellow cyan
# In the first of the above examples, the numbers 1 to 100 are padded to the
# left with spaces to a total of 3 digits. In the second examples, the strings
# are padded to the right with dashes to a total width of 8 characters
# Notes:
#   - If no arguments are given beyond <length> and <char>, the strings to pad
#     are read from stdin.
#   - If a string to pad is longer than <length>, it is printed unchanged.
_pad-left() {
  if [[ "$#" -lt 2 ]]; then
    _print-usage-msg "<length> <char> [<args>...]"
    return 1
  fi
  __pad l "$1" "$2" $(shift 2 && _get-input "$@")
}
_pad-right() {
  if [[ "$#" -lt 2 ]]; then
    _print-usage-msg "<length> <char> [<args>...]"
    return 1
  fi
  __pad r "$1" "$2" $(shift 2 && _get-input "$@")
}
__pad() {
  local direction=$1
  local length=$2
  local char=$3
  shift 3
  for e in "$@"; do
    local fill_length=$(("$length"-"${#e}"))
    [[ "$fill_length" -lt 0 ]] && fill_length=0
    local fill=$(printf '%*s' "$fill_length" | tr ' ' "$char")
    case "$direction" in
      l) echo "$fill$e" ;;
      r) echo "$e$fill" ;;
    esac
  done
}

# Read text from stdin and format it to width of terminal with word wrapping.
# This function is similar to the 'fmt' command, but it preserves all newlines.
# Notes:
#   - awk adds nroff commands to beginning of input (.pl = page length,
#     .ll = line length, .na=disable justification, hy 0 = disable hyphenation)
#   - nroff formats the text
#   - sed reverts the conversion of - to U+2010 (UTF-8 0xE28090) done by nroff
# See https://docstore.mik.ua/orelly/unix3/upt/ch21_03.htm
_wrap() {
  awk -v c=$(tput cols) '
    BEGIN {printf ".pl 1\n.ll %d\n.na\n.hy 0\n", c}
    {print}' |
    nroff |
    sed 's/\xE2\x80\x90/-/g'
}

#=-----------------------------------------------------------------------------#
# Number processing
#------------------------------------------------------------------------------#

# Calculate the logarithm of a given number to a given base
# Usage:
#   log <base> <n> [-i]
# Description:
#   Prints the logarithm of <n> with respect to <base>. If -i is supplied as
#   the last argument, the result rounded to the nearest integer that is lower
#   than the result.
_log() {
  local base=$1 n=$2
  local result=$(bc -l <<<"l($n) / l($base)")
  if [[ "${@: -1}" = -i ]]; then
    _floor "$result"
  else
    echo "$result"
  fi
}

# Calculate the logarithm of two for a given number
# Usage:
#   log2 <n> [-i]
# Description:
#   Prints the logarithm of 2 of <n>. If -i is supplied as the last argument,
#   the result is rounded to the nearest integer that is lower than the result.
_log2() {
  _log 2 "$@"
}

# Calculate the logarithm of ten for a given number
# Usage:
#   log10 <n> [-i]
# Description:
#   Prints the logarithm of 10 of <n>. If -i is supplied as the last argument,
#   the result is rounded to the nearest integer that is lower than the result.
_log10() {
  _log 10 "$@"
}

# Round number ($1) to specific number of digits ($2) after decimal point
_round() {
  printf "%.$2f\n" "$1"
}

# Round number down to nearest integer
_floor() {
  bc <<<"$1/1"
}

#=-----------------------------------------------------------------------------#
# Array processing
#------------------------------------------------------------------------------#

_array-print() {
  _ensure-argc-1 "$#" "<array-name>" && _ensure-var-name "$1" && _ensure-array "$1" || return 1
  echo "$(_array-type "$1" | _to-title-case):"
  local -n __ref=$1
  local i
  for i in ${!__ref[@]}; do
    echo "[$i]=${__ref[$i]}"
  done
}

# Return the type of an array variable.
# Usage:
#   _array-type <array-name>
# Returns either 'indexed' or 'associative'. If the passed name does not belong
# to an array variable, the function returns an error.
_array-type() {
  _ensure-argc-1 "$#" "<array-name>" && _ensure-var-name "$1" && _ensure-array "$1" || return 1
  local -n __ref=$1
  case "${__ref@a}" in
    a) echo indexed ;;
    A) echo associative ;;
  esac
}

# Test if an array contains a specific element.
# Usage:
#   _array-has <array> <element>
# Example:
#   _array-has "${myarr[@]}" foo
_array-has() {
  if [[ "$#" -lt 1 ]]; then
    _print-usage-msg "<array> <element>"
    return 1
  fi
  local array=("${@:1:$#-1}")
  local element=${@:$#}
  for i in "${!array[@]}"; do
    [[ "${array[$i]}" = "$element" ]] && return 0
  done
  return 1
}

# Join the elements of an array with a delimiter.
# Usage:
#   _array-join <array> <delimiter>
# Example:
#   _array-join "${myarr[@]}" ::
# The above example joins the elements of the array with a '::' delimiter.
# A delimiter may be an arbitrary string.
_array-join() {
  [[ "$#" -lt 1 ]] && _print-error-msg "must specify array and delimiter" && return 1
  local array=("${@:1:$#-1}")
  local d=${@:$#}
  local str="${array[0]}"
  for e in "${array[@]:1}"; do
    str+="$d$e"
  done
  echo "$str"
}

# Remove all occurrences of a specific element from an array.
# Usage:
#   _array-remove <array> <element> <out_array_name>
# Example:
#   _array-remove "${myarr[@]}" foo result
# In the above example, all "foo" elements are removed from the 'myarr' array
# and the resulting array is saved in a variable named 'result'.
# Notes:
#   - The result array DOESN'T need to be declared in the calling function, but
#     it's advisable to declare it with 'local' in order to keep it local.
#   - The assignment to the passed in result array name is implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_array-remove() {
  [[ "$#" -lt 2 ]] && _print-error-msg "must specify array, element to remove, and name of result variable" && return 1
  local in_array=("${@:1:$#-2}")
  local element=${@:$#-1:1}
  local -n __ref=${@:$#}
  __ref=()
  for i in "${!in_array[@]}"; do
    if [[ "${in_array[$i]}" != "$element" ]]; then
      __ref+=("${in_array[$i]}")
    fi
  done
}

# Split arguments into two arrays separated by a delimiter.
# Usage:
#   _splitargs <array_name_1> <arrary_name_2> <delimiter> <args>...
# Args:
#   <array_name_1>  Name of array variable for elements before delimiter
#   <array_name_2>  Name of array variable for elements after delimiter
#   <delimiter>     Delimiter string 
#   <args>...       Argument sequence containing elements and delimiter
# Example:
#   _splitargs a1 a2 -- foo bar -- baz kux
# The above assigns ["foo" "bar"] to a variable named 'a1' and ["baz" "kux"] to
# a variable named 'a2'. These variables can be used in the calling context.
# Notes:
#   - The variable names DON'T need to be declared in the calling function, but
#     it's advisable to declare them with 'local' in order to keep them local.
#   - If <args>... does not contain the delimiter, then all elements are
#     assigned to <array_name_1> (and <array_name_2> is left empty)
#   - If <args>... contains multiple occurrences of the delimiter, then the
#     split happens at the first of these delimiters.
#   - The passed variable names must not be '__ref1' and '__ref2' as these are
#     internally used (otherwise, a "circular name reference" error occurs).
#   - The assignments to the passed in variable names are implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_splitargs() {
  local -n __ref1=$1 __ref2=$2
  local d=$3
  shift 3
  local i
  for i in $(seq "$#"); do
    if [[ "${!i}" = "$d" ]]; then
      __ref1=("${@:1:$(($i-1))}")  # Arguments before delimiter
      __ref2=("${@:$(($i+1))}")    # Arguments after delimiter
      return
    fi
  done
  # If no delimiter found
  __ref1=("$@")
}

#=-----------------------------------------------------------------------------#
# Filename processing
#------------------------------------------------------------------------------#

# Insert string ($2) into filename ($1), just before filename extension.
# Add a suffix to a file basename, just before the extension
# Usage:
#   _insert-basename-suffix <suffix> <file>
# Example:
#   _insert-basename-suffix -foo test.txt  ==>  test-foo.txt
_insert-basename-suffix() {
  local suffix=$1
  local file=$2
  echo "${file/%.+([^.])/$suffix&}"  # TODO: replace below with this (requires shopt options patsub_replacement for & and extglob for +())
  echo "${file%.*}${suffix}.${file##*.}"
}

# Change the extension of a file name.
# Usage:
#   _change-filename-extension <file> <extension>
# Example:
#   _change-filename-extension test.txt md  ==>  test.md
_change-filename-extension() {
  echo "${1%.*}.$2"
}
