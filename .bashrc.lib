# ~/.bashrc.lib
#
# Shell function library. All functions starting with a single underscore are
# intended to be used by other .bashrc.* files.
#------------------------------------------------------------------------------#

#=-----------------------------------------------------------------------------#
# .bashrc.* files
#------------------------------------------------------------------------------#

  # List ~/.bashrc.* files in the order in which they are sourced in ~/.bashrc
_bashrc() {
  echo ~/.bashrc.path ~/.bashrc.lib ~/.bashrc.main ~/.bashrc.!(path|lib|main)
}

#=-----------------------------------------------------------------------------#
# Input/output
#------------------------------------------------------------------------------#

# Print either the arguments, if arguments are provided, or stdin, if no
# arguments are provided.
# Usage:
#   _get-input [<args>...]
# Notes:
#   - The intended usage of this function is allowing other functions to gather
#     their input either from the argument list or from stdin (if no arguments
#     are provided).
#   - The tokenisation of the argument list is NOT maintained, i.e. the arg 
#     list is reproduced as a plain string.
# Example application:
#   my-function() {
#     _get-input "$@" | ...
#   }
_get-input() {
  if [[ "$#" -gt 0 ]]
    then echo "$*"
  else
    echo "$(</dev/stdin)"
  fi
}

# Print an error message to stderr.
# Usage:
#   _print-error-msg [<func-depth>] <msg>
# The optional <func-depth> argument is the position of the function in the
# function call stack whose named should be printed along with the error
# message. The default value is 1, which is the calling function.
#

# Print all arguments to stderr.
_stderr() {
  echo -e "$@" >/dev/stderr
}

# Print a an error message.
# Usage:
#   _print-error-msg <msg> [<func-stack-index>]
# Notes:
#   - The <func-stack-index> argument is the position of the function in the
#     function call stack whose name should be printed as part of the output.
#     Its default value is 1, which corresponds to the function that called
#     this function.
#   - The <msg> argument must be passed a a single argument, that means, it
#     must be wrapped in quotes.
#   - The <msg> argument may contain formatting characters, such as \n or \t.
_print-error-msg() {
  local msg=$1
  local i=${2:-1}
  echo -e "Error (${FUNCNAME["$i"]}): $msg"
}

# Print a multi-line usage message, like the one below, to stderr.
# Usage:
#   _print-usage-msg <msg> [<func-stack-index>]
# Notes:
#   - The <func-stack-index> argument is the position of the function in the
#     function call stack whose name should be printed in the second line. Its
#     default value is 1, which corresponds to the function that called the
#     _print-usage-msg function.
#   - The <msg> argument must be passed a a single argument, that means, it
#     must be wrapped in quotes.
#   - The <msg> argument may contain formatting characters, such as \n or \t.
_print-usage-msg() {
  local msg=$1
  local i=${2:-1}
  echo -e "Usage:\n  ${FUNCNAME["$i"]} $msg"
}

# Print a message to stdout ONLY if stdout is directed to the terminal
_print-cond-out() {
  if [[ -t 1 ]]; then
    printf "$@"
  fi
}

# Print a message to stderr ONLY if stderr is directed to the terminal
_print-cond-err() {
  if [[ -t 2 ]]; then
    printf "$@" >>/dev/stderr
  fi
}

# Print a message to stdout and apply Select Graphic Rendition (SGR) formatting
# ONLY if stdout is directed to a terminal (otherwise omit the SGR formatting).
# Usage:
#   _print-cond-sgr-out [<sgr-arg>...] <msg>
# Notes:
# The <sg-args> args correspond to the arguments accepted by the _sgr function.
_print-cond-sgr-out() {
  local sgr_args=(${@:$#-2})
  local msg=${@:$#}
  if [[ -t 1 ]]; then
    echo "$(_sgr "${sgr_args[@]}")$msg$(_sgr)"
  else
    echo "$msg"
  fi
}

# Print a message to stderr and apply Select Graphic Rendition (SGR) formatting
# ONLY if stderr is directed to a terminal (otherwise omit the SGR formatting).
# Usage:
#   _print-cond-sgr-err [<sgr-arg>...] <msg>
# Notes:
# The <sg-args> args correspond to the arguments accepted by the _sgr function.
_print-cond-sgr-err() {
  local sgr_args=(${@:$#-2})
  local msg=${@:$#}
  if [[ -t 2 ]]; then
    echo "$(_sgr "${sgr_args[@]}")$msg$(_sgr)" >/dev/stderr
  else
    echo "$msg" >/dev/stderr
  fi
}

# Print a Select Graphic Rendition (SGR) [1] string to set display attributes.
# Usage:
#   _sgr [<colour/modifier>...]
# Available colours:
#   black, black+, red, red+, green, green+, yellow, yellow+, blue, blue+,
#   magenta, magenta+, cyan, cyan+, white, white+
# Available modifiers:
#   x (reset), b (bold), d (dim), i (italic), u (underline)
# Notes:
#   - Colours with a + are the bright versions of the corresponding colours
#   - The x modifier resets all set attributes (colours and modifiers). The
#     same effect can be achieved by omitting any arguments.
#   - Modifiers may be combined into a single argument
# Examples:
#   _sgr red        // Red 
#   _sgr red+       // Bright red 
#   _sgr red b      // Bold red
#   _sgr red biu    // Bold, italic, and underlined red
#   _sgr red b i u  // Same as above
#   _sgr bu         // Bold and underlined (colour isn't changed)
#   _sgr x          // Reset all previously set attributes
#   _sgr            // Same as above
#   echo "$(_sgr red bi)red $(_sgr x blue+ u)blue$(_sgr) normal"
# [1] https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
_sgr() {
  local p
  for a in "$@"; do
    # Parse colour
    case "$a" in
      black)    p+=(30); continue ;;
      red)      p+=(31); continue ;;
      green)    p+=(32); continue ;;
      yellow)   p+=(33); continue ;;
      blue)     p+=(34); continue ;;
      magenta)  p+=(35); continue ;;
      cyan)     p+=(36); continue ;;
      white)    p+=(37); continue ;;
      black+)   p+=(90); continue ;;
      red+)     p+=(91); continue ;;
      green+)   p+=(92); continue ;;
      yellow+)  p+=(93); continue ;;
      blue+)    p+=(94); continue ;;
      magenta+) p+=(95); continue ;;
      cyan+)    p+=(96); continue ;;
      white+)   p+=(97); continue ;;
    esac
    # Parse modifiers (x, b, i, u, d)
    a=($(grep -o . <<<"$a"))
    for i in "${a[@]}"; do
      case "$i" in
        x) p+=(0) ;;  # Reset
        b) p+=(1) ;;  # Bold
        d) p+=(2) ;;  # Dim
        i) p+=(3) ;;  # Italic
        u) p+=(4) ;;  # Underlined
      esac
    done
  done
  # Print escape sequence
  printf "\e[$(tr ' ' ';' <<<"${p[@]}")m"
}

#=-----------------------------------------------------------------------------#
# Check OS
#------------------------------------------------------------------------------#

# Check if running on macOS, Linux, or WSL2 (special case of Linux)
_is-mac() {
  [[ "$OSTYPE" =~ darwin ]]
}
_is-linux() {
  [[ "$OSTYPE" =~ linux  ]]
}
_is-wsl() {
  _is-linux && [[ -n "$WSL_DISTRO_NAME" ]]
}

#=-----------------------------------------------------------------------------#
# Check variables
#------------------------------------------------------------------------------#

# Check if variable is set (i.e. non-empty) or unset (i.e. empty)?
_is-set() {
  [[ -n "$1" ]]
}
_is-unset() {
  [[ -z "$1" ]]
}

#=-----------------------------------------------------------------------------#
# Check commands
#------------------------------------------------------------------------------#

# Check whether a given command is a shell function
_is-function() {
  [[ "$(type -t "$1")" = function ]]
}
complete -A function _is-function

# Check whether a given command is a shell alias
_is-alias() {
  [[ "$(type -t "$1")" = alias ]]
}
complete -a _is-alias

# Check whether a given command is a shell builtin
_is-builtin() {
  [[ "$(type -t "$1")" = builtin ]]
}
complete -b _is-builtin

# Check whether a given command is an executable file in the PATH
_is-exec-file() {
  [[ "$(type -t "$1")" = file ]]
}
complete -c _is-exec-file

# Check whether a given command exists (i.e. is either an executable file in 
# the path, an alias, a function, or a shell builtin)
_is-cmd() {
  _is-exec-file "$1" || _is-alias "$1" || _is-function "$1" || _is-builtin "$1"
}
complete -c _is-cmd

# List all the types of a command.
# Usage:
#   _type [-s] <cmd>
# Lists all the types (function, alias, file, or builtin) for <cmd> in order
# of precedence. For files, functions, and aliases, the source file is also
# listed. For functions and aliases, the line number of the definition is
# additionally appended to the filename. With -s, only the highest precedence
# type (i.e. the one taking effect) is listed.
# Notes:
#   - This function is similar to 'type -a', however, it does NOT list function
#     and alias bodies (use 'doc' for this), but in turn it lists file names
#     and line numbers for functions and aliases.
#   - Alias definitions are parsed from the .bashrc.* files (see '_bashrc').
#     In order to be parsed correctly, alias definitions must only have white-
#     space between the 'alias' keyword and the beginning of the line.
_type() {
  if [[ "$#" -eq 1 ]]; then
    local cmd=$1
  elif [[ "$#" -eq 2 && "$1" = -s ]]; then
    local short=1 cmd=$2
  else
    _print-usage-msg "[-s] <cmd>" >/dev/stderr
    return 1
  fi
  local types=$(type -ta "$cmd")
  if _is-set "$short"; then
    types=$(echo "$types" | head -n 1)
  fi
  local file_i
  echo "$types" | while read t; do
    case "$t" in
      function)
        { shopt -s extdebug; local res=$(declare -F "$cmd"); shopt -u extdebug; }
        local file=$(echo "$res" | cut -d ' ' -f 3-)
        local line=$(echo "$res" | cut -d ' ' -f 2)
        __type-print function "$([[ "$file" =~ ^/ ]] && echo "$file:$line")"
        ;;
      alias)
        __type-print alias "$(grep -nE "^[ ]*alias[ ]+$cmd=" $(_bashrc) /dev/null | tail -n 1 | cut -d : -f 1-2)"
        ;;
      file)
        ((file_i++))
        __type-print file "$(which -a "$cmd" | sed -n "${file_i}p")"
        ;;
      builtin)
        __type-print builtin
        ;;
    esac
  done
}
complete -c _type
__type-print() {
  echo "$1,${2:-null}"
}

# Print an error message and return 1 if the given command does NOT exist
# Usage example:
#   my-function() {
#     _ensure-installed <cmd> || return 1
#   }
_ensure-installed() {
  if ! _is-cmd "$1"; then
    _print-error-msg "'$1' is not installed" 2
    return 1
  fi
}

# Check whether a given Homebrew formula or cask is installed
# Note: also checks whether Homebrew is installed, and aborts otherwise
_is-homebrew-poured() {
  _ensure-installed brew || return 1
  brew ls --versions "$1" >/dev/null || brew ls --cask --versions "$1" >/dev/null
}

#=-----------------------------------------------------------------------------#
# Text processing
#------------------------------------------------------------------------------#

# Transform the input to upper-case
# Usage:
#   _to-upper-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-upper-case() {
  _get-input "$@" |
  tr '[:lower:]' '[:upper:]'
}

# Transform the input to lower-case
# Usage:
#   _to-lower-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-lower-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]'
}

# Transform the input to title-case (first letter of each word capitalised).
# Usage:
#   _to-title-case [<args>...]
# If no arguments are provided, the input is read from stdin.
_to-title-case() {
  _get-input "$@" |
  awk '{
    for (i=1; i<=NF; i++) {
      $i = toupper(substr($i,1,1)) substr($i,2)
    }
  }
  { print }'
}

# Transform the input to kebab-case (lower-case joined by dashes)
# Usage:
#   _to-kebab-case [<args>...]
# If no arguments are provided, the input is read from stdin.
# Notes:
#   - This implementation of kebab-case involves the following:
#     1. All characters are transformed to lower-case
#     2. Punctuation characters (except '-') are deleted
#     3. Whitespace characters are replaced by dashes 
#     4. Repeated dashes replaced with a single dash
#     5. Dashes at the beginning and end of strings are omitted
_to-kebab-case() {
  _get-input "$@" |
  tr '[:upper:]' '[:lower:]' |
  tr - ' ' |
  sed 's/[[:punct:]]//g;s/[[:space:]]/-/g' |
  tr -s - |
  sed 's/^-//;s/-$//'
}

# Pad a list of strings up to a desired total length.
# Usage:
#   _pad-left <length> <char> [<args>...]
#   _pad-right <length> <char> [<args>...]
# Example:
#   _pad-left 3 ' ' $(seq 100)
#   _pad-right 8 - red green blue yellow cyan
# In the first of the above examples, the numbers 1 to 100 are padded to the
# left with spaces to a total of 3 digits. In the second examples, the strings
# are padded to the right with dashes to a total width of 8 characters
# Notes:
#   - If no arguments are given beyond <length> and <char>, the strings to pad
#     are read from stdin.
#   - If a string to pad is longer than <length>, it is printed unchanged.
_pad-left() {
  [[ "$#" -lt 2 ]] && _print-error-msg "must provide length and padding character" && return 1
  __pad l "$1" "$2" $(shift 2 && _get-input "$@")
}
_pad-right() {
  [[ "$#" -lt 2 ]] && _print-error-msg "must provide length and padding character" && return 1
  __pad r "$1" "$2" $(shift 2 && _get-input "$@")
}
__pad() {
  local direction=$1
  local length=$2
  local char=$3
  shift 3
  for e in "$@"; do
    local fill_length=$(("$length"-"${#e}"))
    [[ "$fill_length" -lt 0 ]] && fill_length=0
    local fill=$(printf '%*s' "$fill_length" | tr ' ' "$char")
    case "$direction" in
      l) echo "$fill$e" ;;
      r) echo "$e$fill" ;;
    esac
  done
}

# Read text from stdin and format it to width of terminal with word wrapping.
# This function is similar to the 'fmt' command, but it preserves all newlines.
# Notes:
#   - awk adds nroff commands to beginning of input (.pl = page length,
#     .ll = line length, .na=disable justification, hy 0 = disable hyphenation)
#   - nroff formats the text
#   - sed reverts the conversion of - to U+2010 (UTF-8 0xE28090) done by nroff
# See https://docstore.mik.ua/orelly/unix3/upt/ch21_03.htm
_wrap() {
  awk -v c=$(tput cols) '
    BEGIN {printf ".pl 1\n.ll %d\n.na\n.hy 0\n", c}
    {print}' |
    nroff |
    sed 's/\xE2\x80\x90/-/g'
}

#=-----------------------------------------------------------------------------#
# Array processing
#------------------------------------------------------------------------------#

# Print the elements of an array with indices (alternative to 'declare -p <a>')
_array-print() {
  [[ "$#" -eq 0 ]] && return
  for i in $(seq "$#"); do
    echo "[$(($i-1))]: ${!i}"
  done
}

# Test if an array contains a specific element.
# Usage:
#   _array-has <array> <element>
# Example:
#   _array-has "${myarr[@]}" foo
_array-has() {
  [[ "$#" -lt 1 ]] && _print-error-msg "must specify array and element to check for" && return 1
  local array=("${@:1:$#-1}")
  local element=${@:$#}
  for i in "${!array[@]}"; do
    [[ "${array[$i]}" = "$element" ]] && return 0
  done
  return 1
}

# Join the elements of an array with a delimiter.
# Usage:
#   _array-join <array> <delimiter>
# Example:
#   _array-join "${myarr[@]}" ::
# The above example joins the elements of the array with a '::' delimiter.
# A delimiter may be an arbitrary string.
_array-join() {
  [[ "$#" -lt 1 ]] && _print-error-msg "must specify array and delimiter" && return 1
  local array=("${@:1:$#-1}")
  local d=${@:$#}
  local str="${array[0]}"
  for e in "${array[@]:1}"; do
    str+="$d$e"
  done
  echo "$str"
}

# Remove all occurrences of a specific element from an array.
# Usage:
#   _array-remove <array> <element> <out_array_name>
# Example:
#   _array-remove "${myarr[@]}" foo result
# In the above example, all "foo" elements are removed from the 'myarr' array
# and the resulting array is saved in a variable named 'result'.
# Notes:
#   - The result array DOESN'T need to be declared in the calling function, but
#     it's advisable to declare it with 'local' in order to keep it local.
#   - The assignment to the passed in result array name is implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_array-remove() {
  [[ "$#" -lt 2 ]] && _print-error-msg "must specify array, element to remove, and name of result variable" && return 1
  local in_array=("${@:1:$#-2}")
  local element=${@:$#-1:1}
  local -n __ref=${@:$#}
  __ref=()
  for i in "${!in_array[@]}"; do
    if [[ "${in_array[$i]}" != "$element" ]]; then
      __ref+=("${in_array[$i]}")
    fi
  done
}

# Split arguments into two arrays separated by a delimiter.
# Usage:
#   _splitargs <array_name_1> <arrary_name_2> <delimiter> <args>...
# Args:
#   <array_name_1>  Name of array variable for elements before delimiter
#   <array_name_2>  Name of array variable for elements after delimiter
#   <delimiter>     Delimiter string 
#   <args>...       Argument sequence containing elements and delimiter
# Example:
#   _splitargs a1 a2 -- foo bar -- baz kux
# The above assigns ["foo" "bar"] to a variable named 'a1' and ["baz" "kux"] to
# a variable named 'a2'. These variables can be used in the calling context.
# Notes:
#   - The variable names DON'T need to be declared in the calling function, but
#     it's advisable to declare them with 'local' in order to keep them local.
#   - If <args>... does not contain the delimiter, then all elements are
#     assigned to <array_name_1> (and <array_name_2> is left empty)
#   - If <args>... contains multiple occurrences of the delimiter, then the
#     split happens at the first of these delimiters.
#   - The passed variable names must not be '__ref1' and '__ref2' as these are
#     internally used (otherwise, a "circular name reference" error occurs).
#   - The assignments to the passed in variable names are implemented through
#     the nameref attribute [1] (requires at least Bash 4.3)
# [1] https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html
_splitargs() {
  local -n __ref1=$1 __ref2=$2
  local d=$3
  shift 3
  for i in $(seq "$#"); do
    if [[ "${!i}" = "$d" ]]; then
      __ref1=("${@:1:$(($i-1))}")  # Arguments before delimiter
      __ref2=("${@:$(($i+1))}")    # Arguments after delimiter
      return
    fi
  done
  # If no delimiter found
  __ref1=("$@")
}

#=-----------------------------------------------------------------------------#
# Filename processing
#------------------------------------------------------------------------------#

# Insert string ($2) into filename ($1), just before filename extension.
# Add a suffix to a file basename, just before the extension
# Usage:
#   _insert-basename-suffix <suffix> <file>
# Example:
#   _insert-basename-suffix -foo test.txt  ==>  test-foo.txt
_insert-basename-suffix() {
  local suffix=$1
  local file=$2
  echo "${file%.*}${suffix}.${file##*.}"
}

# Change the extension of a file name.
# Usage:
#   _change-filename-extension <file> <extension>
# Example:
#   _change-filename-extension test.txt md  ==>  test.md
_change-filename-extension() {
  echo "${1%.*}.$2"
}
