# ~/.bashrc.util
#
# General-purpose end-user functions.
#------------------------------------------------------------------------------#

#------------------------------------------------------------------------------#
# Shell operations
#------------------------------------------------------------------------------#

# Enable/disable vi line-editing mode in shell input (Readline)
vi-mode-on() {
  bind 'set editing-mode vi'  # Equivalen to 'set -o vi'
  bind 'set show-mode-in-prompt on'
  bind 'set vi-ins-mode-string \1\033[1;32m@|\033[m\2'
  bind 'set vi-cmd-mode-string \1\033[1;42;37m@\033[;1;32m|\033[m\2'
  bind '"\C-k": vi-movement-mode'
}

vi-mode-off() {
  bind 'set editing-mode emacs'  # Equivalen to 'set +o vi'
  bind 'set show-mode-in-prompt off'
}

# Show the source file and line where a function is defined
funcfile() {
  shopt -s extdebug
  declare -F "$1"
  shopt -u extdebug
}
# Allow completion of function names
complete -A function funcfile

# Search through the central history file (see PROMPT_COMMAND) and either
# print or directly execute the selected command
# TODO: paste the command on the command line without executing it
hist() {
  _ensure-installed fzf
  # Directly execute the command
  if [[ "$1" = -x ]]; then
    eval $(cat "$HISTFILE" | fzf -e --tac)
  # Print the command to stdout
  else
    cat "$HISTFILE" | fzf -e --tac
  fi
}

#------------------------------------------------------------------------------#
# Terminal colours
#------------------------------------------------------------------------------#

# Print the 8 base colours of this terminal (black, red, green, yellow, blue,
# magenta, cyan, white) in normal, bright, and bold variations.
# Usage:
#   c8 [c]...
# Args:
#   c: ANSI colour code for one of the 8 base colours and their bright versions.
#      Possible values are: 30-37 (normal colours) and 90-97 (bright versions).
# Note:
#   If no arguments are given, all colours are printed.
c8() {
  local c=(${@:-30 90 31 91 32 92 33 93 34 94 35 95 36 96 37 97})
  _array-has "${c[@]}" 30 && printf "\e[47;30mBlack (30):\e[49m          \e[040m   \e[49m  \e[47mNormal\e[49m  \e[47;1mBold\e[0m\n"
  _array-has "${c[@]}" 90 && printf "\e[90mBright black (90):   \e[100m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 31 && printf "\e[31mRed (31):            \e[041m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 91 && printf "\e[91mBright red (91):     \e[101m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 32 && printf "\e[32mGreen (32):          \e[042m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 92 && printf "\e[92mBright green (92):   \e[102m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 33 && printf "\e[33mYellow (33):         \e[043m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 93 && printf "\e[93mBright yellow (93):  \e[103m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 34 && printf "\e[34mBlue (34):           \e[044m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 94 && printf "\e[94mBright blue (94):    \e[104m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 35 && printf "\e[35mMagenta (35):        \e[045m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 95 && printf "\e[95mBright magenta (95): \e[105m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 36 && printf "\e[36mCyan (36):           \e[046m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 96 && printf "\e[96mBright cyan (96):    \e[106m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 37 && printf "\e[37mWhite (37):          \e[047m   \e[49m  Normal  \e[1mBold\e[0m\n"
  _array-has "${c[@]}" 97 && printf "\e[97mBright white (97):   \e[107m   \e[49m  Normal  \e[1mBold\e[0m\n"
  return 0
}

# Print all 256 colours if this is a 256-colour terminal.
# Usage:
#   c256 [columns] [string]
# Args:
#   columns: number of columns in the output (default: 6)
#   string:  string to print for each colour (default: "colour-")
# Example:
#  c256 6 ABCDEF
c256() {
  local n=$(tput colors)
  if [[ "$n" != 256 ]]; then
    echo "Not a 256 colour terminal (only $n colours)"
    return 1
  fi
  local columns=${1:-6}
  local string=${2:-colour-}
  for i in {0..255} ; do
    printf "\e[38;5;${i}m${string}$(_pad-left 3 0 "$i") "
    [[ $((($i + 1) % $columns)) = 0 && "$i" -lt 255 ]] && echo
  done
  printf "\e[0m\n"
}

# Print coloured message to stdout/stderr if connected to terminal and omit the
# colours if not connected to a terminal.
# Usage:
#   echoc <colour-attribute>... <msg>
# Examples:
#   echoc red b "Foo bar"         # Print red bold message to stdout
#   echoc red b "Foo bar" >out    # Colours omitted because stdout is file
#   echocerr red b "Foo bar"      # Print red bold message to stderr
echoc() { __echoc 1 "$@"; }
echocerr() { __echoc 2 "$@"; }
__echoc() {
  local fd=$1
  local c_args=(${@:2:$#-2})
  local msg=${@:$#}
  [[ -t "$fd" ]] && msg=$(_sgr "${c_args[@]}")$msg$(_sgr)
  if [[ "$fd" -eq 1 ]]; then
    echo "$msg"
  elif [[ "$fd" -eq 2 ]]; then
    echo "$msg" >/dev/stderr
  else
    return 1
  fi
}

#------------------------------------------------------------------------------#
# Text processing
#------------------------------------------------------------------------------#

# Create random alphanumeric lower-case string of the specified length
random() {
  local length=${1:-16}
  [[ "$length" =~ ^[1-9][0-9]*$ ]] || { echo "Argument must be positive integer"; return 1; }
  cat /dev/urandom | LC_ALL=C tr -dc a-z0-9 | head -c "$length"
  echo
}

# Generate a random hexadecimal string of the specified length
random-hex(){
  local digits=$1
  cat /dev/urandom | head -c $((("$digits"/2)+1)) | hexdump -e '"%x"' | head -c "$digits"
  echo
}

# Get the Unicode code point of a single character (source [1])
# [1] https://superuser.com/a/1019853
unicode() {
  local char=$(_get-input "$@")
  [[ "${#char}" -ne 1 ]] && { _error "must pass a single character"; return 1; }
  echo -n "$char" | iconv -f UTF-8 -t UTF-32BE | xxd -p | sed -r 's/^0+/0x/' | xargs printf 'U+%04X\n'
}

#------------------------------------------------------------------------------#
# Number processing
#------------------------------------------------------------------------------#

log2() {
  bc -l <<<"l($1) / l(2)"
}
log10() {
  bc -l <<<"l($1) / l(10)"
}

# Round number ($1) to specific number of digits ($2) after decimal point
round() {
  printf "%.$2f\n" "$1"
}

# Round number down to nearest integer
floor() {
  bc <<<"$1/1"
}

# Test if number is even or odd
is-even() {
  (($1 % 2 == 0))
}
is-odd() {
  (($1 % 2 != 0))
}

# Convert numbers between numeral systems. Input read from stdin or arg list.
d2b() { __x2x 10  2 0    "$@"; }
d2o() { __x2x 10  8 0    "$@"; }
d2h() { __x2x 10 16 0    "$@"; }
b2d() { __x2x  2 10 0    "$@"; }
o2d() { __x2x  8 10 0    "$@"; }
h2d() { __x2x 16 10 0    "$@"; }
h2b() { __x2x 16  2 4    "$@"; }
h2o() { __x2x 16  8 0    "$@"; }
b2h() { __x2x  2 16 0.25 "$@"; }
o2h() { __x2x  8 16 0    "$@"; }
b2o() { __x2x  2  8 0.33 "$@"; }
o2b() { __x2x  8  2 3    "$@"; }
# Read input from stdin or arg list
__x2x() {
  (($# == 3)) && ____x2x "$@" $(</dev/stdin) || ____x2x "$@"
}
# Convert numbers and zero-pad based on number of digits and value of arg 3
____x2x() {
  local tok
  for tok in $(_upper-case ${@:4}); do
    bc <<< "obase=$2; ibase=$1; $tok" | _pad-left $(bc <<<"(${#tok}*$3)/1" 0)
  done
}

# Print a number in binary, octal, decimal, and hexadecmial formats. The input
# number may be provided as a binary, octal, decimal, or hexadecimal number.
# Usage:
#   n <number>
# Examples:
#   n 0b10  // Binary
#   n 010   // Octal
#   n 10    // Decimal
#   n 0x10  // Hexadecimal
n() {
  local PAT_BIN='^0b([01]+)$'
  local PAT_OCT='^0([0-7]+)$'
  local PAT_DEC='^([1-9][0-9]*)$'
  local PAT_HEX='^0x([0-9a-fA-F]+)$'
  local PAT_0='^(0)$'
  local n
  # Convert number to decimal as an intermediary format
  if   [[ $1 =~ $PAT_HEX ]]; then n=$(h2d ${BASH_REMATCH[1]})
  elif [[ $1 =~ $PAT_BIN ]]; then n=$(b2d ${BASH_REMATCH[1]})
  elif [[ $1 =~ $PAT_OCT ]]; then n=$(o2d ${BASH_REMATCH[1]})
  elif [[ $1 =~ $PAT_DEC || $1 =~ $PAT_0 ]]; then n=${BASH_REMATCH[1]}
  else
    echo "Invalid number: $1" && return 1
  fi
  # Convert from decimal to other systems
  echo "$(d2b $n)"
  echo "$(d2o $n)"
  echo "$n"
  echo "$(d2h $n)"
}

#------------------------------------------------------------------------------#
# Date and time processing
#------------------------------------------------------------------------------#

# Convert a number of seconds to a "<X>m <Y>s" representation.
sec2min() {
  echo "$(("$1"/60))m $(("$1"%60))s"
}

if _is-mac; then
  # Convert a date string in a specific format to a UNIX timestamp in seconds.
  # If the date string doesn't include a time, the current time is assumed.
  # Usage:
  #   date2ts <date> <date_format>
  # Example:
  #   date2ts "2016-02-02 13:21:45" "%Y-%m-%d %H:%M:%S"
  date2ts() {
    # '-j' disables setting of system date, '-f' is the format of input date
    date -j -f "$2" "$1" '+%s'
  }

  # Convert a UNIX timestamp in seconds to a date string. The format of the
  # output date string can be optinally specified (e.g. '+%Y-%m-%d %H:%M:%S').
  # Usage:
  #   ts2date <timestamp> [<out_format>]
  ts2date() {
    date -r "$@"
  }
elif _is-linux; then
  # Convert a date string to a UNIX timestamp in seconds. The date string format
  # is the one described in the 'date' man page as '--date=STRING'.
  # Usage:
  #   date2ts <date>
  date2ts() {
    date -d "$1" '+%s'
  }

  # Convert a UNIX timestamp in seconds to a date string. The format of the
  # output date string can be optionally specified (e.g. '+%Y-%m-%d %H:%M:%S').
  # Usage:
  #   ts2date <timestamp> [<out_format>]
  ts2date() {
    _is-set "$2" && date -d "@$1" "$2" || date -d "@$1"
  }
fi

#------------------------------------------------------------------------------#
# Networking
#------------------------------------------------------------------------------#

# Get public IP address of local machine
myip() {
  curl -s checkip.amazonaws.com
}

# Show local ports that are currently in use
ports() {
  lsof -i -P -n | grep LISTEN
}

change_mac() {
  local mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g;s/.$//')
  sudo ifconfig en0 ether "$mac"
  echo "Changed MAC address of en0 device to $mac"
}

#------------------------------------------------------------------------------#
# File system operations
#------------------------------------------------------------------------------#

# Create new directory and navigate into it
mkcd() {
  mkdir "$1" && cd "$1"
}

# Change <n> levels up in the directory hierarchy
cdu() {
  local n=${1:-1}
  for i in $(seq "$n"); do
    cd ..
  done
}

# Change into the directory of the file pointed to by a symlink
cdl() {
  local t=$(readlink "$1")
  cd $([[ -f "$t" ]] && echo $(dirname "$t") || echo "$t")
}
complete -f cdl

# List all the dotfiles or dot-directories in the specified directory.
dotfiles() {
  local d=${1:-.}
  __dotx "${d%/}" f
}
dotdirs() {
  local d=${1:-.}
  __dotx "${d%/}" d
}
__dotx() {
  find "$1" -name '.*' -maxdepth 1 -type "$2" |
  grep -v '^\.$' |
  xargs -Ix basename x |
  sort --ignore-case
}

# Recursively find GB or MB sized directories under the specified directory.
find-gb-dirs() {
  __find-x-dirs g "${1:-.}"
}
find-mb-dirs() {
  __find-x-dirs m "${1:-.}"
}
__find-x-dirs() {
  case "$1" in
    g) local pattern="G$(printf "\t")" ;;
    m) local pattern="M$(printf "\t")\|G$(printf "\t")" ;;
  esac
  sudo du -h "$2" 2>/dev/null | grep "$pattern"
  return 0
}

if _is-mac; then
  # Recursively delete all .DS_Store files in the specified directory
  rmds() {
    sudo find "${1:-.}" -type f \( -name .DS_Store -or -name ._.DS_Store \) -print -delete 2>/dev/null
    return 0
  }

  # Move one or more files or directories to the trash
  trash() {
    for i in "$@"; do
      # mv fails if target directory already exists
      if ! mv "$i" ~/.Trash &>/dev/null; then
        rm -rf ~/.Trash/"$i"
        mv "$i" ~/.Trash
      fi
    done
  }
fi

#------------------------------------------------------------------------------#
# Misc
#------------------------------------------------------------------------------#

# Copy file or stdin to system clipboard
# Usage:
#   clip [file]
# If a file is provided, its content is copied to the clipboard. If no file is
# provided, then stdin is copied to the clipboard.
clip() {
  local cmd
  _is-mac && cmd=pbcopy
  _is-linux && cmd=xclip
  _is-wsl && cmd=clip.exe
  if [[ "$#" -eq 0 ]]; then
    eval "$cmd"
  else
    cat "$1" | eval "$cmd"
  fi
}

# Print operating system name and version
os() {
  if _is-mac; then
    echo "$(sw_vers -productName)-$(sw_vers -productVersion)"
  elif _is-linux; then
    if [[ -f /etc/os-release ]]; then
      (. /etc/os-release; echo "$ID-$VERSION_ID"; )
    else
      echo unknown
    fi
  fi
}

# Dump the hexadecimal code of the provided string (output depends on the 
# encoding used by the terminal).
enc() {
  echo -n "$@" | hexdump | head -1 | cut -d ' ' -f 2-
}

# Print the character encoding used by the terminal
enc-type() {
  echo $LC_CTYPE
}

if _is-mac; then
  # Make Finder hide or show hidden files
  finder-hide-hidden-files() {
    __finder-x-hidden-files FALSE
  }
  finder-show-hidden-files() {
    __finder-x-hidden-files TRUE
  }
  __finder-x-hidden-files() {
    defaults write com.apple.finder AppleShowAllFiles "$1"
    killall Finder
  }

  # Get the bundle ID (e.g. com.apple.Preview) of an application.
  # Note: app names are case insensitive
  app-id() {
    osascript -e "id of app \"$1\""
  }

elif _is-linux; then
  # Check if the dependencies of a Debian package are installed
  checkdep() {
    local dep=($(apt-cache depends "$1" | grep Depends: | cut -d : -f 2))
    for d in "${dep[@]}"; do
      echo -n "$d: "
     if dpkg -s "$d" 2>/dev/null | grep -q "Status: .* installed"; then
        echo installed
      else
        echo "NOT INSTALLED"
      fi
    done
  }

  # Customise keyboard layout with setxkbmap:
  #   - Add Swiss German keyboard layout
  #   - Swap Caps-Lock and Ctrl keys
  #   - Set key combination for toggling between keyboard layouts
  # All the options and keyboard layouts of setxkbmap can be found in the file
  # ==> /usr/share/X11/xkb/rules/base.lst
  # Notes:
  # - The settings made by setxkbmap do NOT persists across logins
  # - To make the settigns persistent, one option would be to put the setxkbmap
  #   commands directly into ~/.bashrc. However, this may cause an X error
  #   (cannot open display "default display")
  # - Another option would be to put the setxkbmap commands into ~/.xinitrc or
  #   /etc/X11/xorg.conf.d/00-keyboard.conf (different syntax). However, there
  #   are inconsistencies across systems, and different desktop environments
  #   read these files in different ways
  # - Because of the above problems, the setxkbmap commands are provided here
  #   as a function that can be called manually
  # Source: https://wiki.archlinux.org/index.php/Keyboard_configuration_in_Xorg
  #         http://betabug.ch/blogs/ch-athens/1242
  config_keyboard() {
    _ensure-installed setxkbmap
    # Set Swiss German and German as keyboard layouts (ch(de) is default)
    setxkbmap 'ch(de),de'
    # Left Alt-Shift for toggling between keyboard layouts
    setxkbmap -option grp:lalt_lshift_toggle
    # Swap Caps-Lock and Ctrl keys
    setxkbmap -option ctrl:swapcaps
  }
fi
