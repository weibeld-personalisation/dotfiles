# ~/.bashrc.util
# Print operating system name and version

os() {
  if is-linux; then
    if [[ -f /etc/os-release ]]; then
      (. /etc/os-release; echo "$ID-$VERSION_ID"; )
    else
      echo unknown
    fi
  elif is-mac; then
    echo "$(sw_vers --productName)-$(sw-vers --productVersion)"
  fi
}

# Capitalise the first letter of a string
capitalize () {
  echo $(echo "${1:0:1}" | tr '[:lower:]' '[:upper:]')"${1:1}"
}

# Create random alphanumeric string (only lower-case) of the specified length.
random() {
  length=${1:-16}
  [[ "$length" =~ ^[1-9][0-9]*$ ]] ||
    { echo "Argument must be positive integer"; return 1; }
  cat /dev/urandom | LC_ALL=C tr -dc a-z0-9 | head -c "$length"
}

# Print the 8 base colours of this terminal (black, red, green, yellow, blue,
# magenta, cyan, white) in normal, bright, and bold variations.
# Usage:
#   c8 [c]...
# Args:
#   c: ANSI colour code for one of the 8 base colours and their bright versions.
#      Possible values are: 30-37 (normal colours) and 90-97 (bright versions).
# Note:
#   If no arguments are given, all colours are printed.
c8() {
  local c=(${@:-30 90 31 91 32 92 33 93 34 94 35 95 36 96 37 97})
  has "${c[@]}" 30 && printf "\e[47;30mBlack (30):\e[49m          \e[040m   \e[49m  \e[47mNormal\e[49m  \e[47;1mBold\e[0m\n"
  has "${c[@]}" 90 && printf "\e[90mBright black (90):   \e[100m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 31 && printf "\e[31mRed (31):            \e[041m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 91 && printf "\e[91mBright red (91):     \e[101m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 32 && printf "\e[32mGreen (32):          \e[042m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 92 && printf "\e[92mBright green (92):   \e[102m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 33 && printf "\e[33mYellow (33):         \e[043m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 93 && printf "\e[93mBright yellow (93):  \e[103m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 34 && printf "\e[34mBlue (34):           \e[044m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 94 && printf "\e[94mBright blue (94):    \e[104m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 35 && printf "\e[35mMagenta (35):        \e[045m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 95 && printf "\e[95mBright magenta (95): \e[105m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 36 && printf "\e[36mCyan (36):           \e[046m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 96 && printf "\e[96mBright cyan (96):    \e[106m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 37 && printf "\e[37mWhite (37):          \e[047m   \e[49m  Normal  \e[1mBold\e[0m\n"
  has "${c[@]}" 97 && printf "\e[97mBright white (97):   \e[107m   \e[49m  Normal  \e[1mBold\e[0m\n"
  return 0
}

# Print all 256 colours if this is a 256-colour terminal.
# Usage:
#   c256 [columns] [string]
# Args:
#   columns: number of columns in the output (default: 6)
#   string:  string to print for each colour (default: "colour-")
# Example:
#  c256 6 ABCDEF
c256() {
  local n=$(tput colors)
  if [[ "$n" != 256 ]]; then
    echo "Not a 256 colour terminal (only $n colours)"
    return 1
  fi
  columns=${1:-6}
  string=${2:-colour-}
  for i in {0..255} ; do
    printf "\e[38;5;${i}m${string}$(pad 3 "$i") "
    [[ $((($i + 1) % $columns)) = 0 && "$i" -lt 255 ]] && echo
  done
  printf "\e[0m\n"
}

# Print coloured message to stdout/stderr if connected to terminal and omit the
# colours if not connected to a terminal.
# Usage:
#   c-echo <colour-attribute>... <msg>
# Examples:
#   c-echo red b "Foo bar"         # Print red bold message to stdout
#   c-echo red b "Foo bar" >out    # Colours omitted because stdout is file
#   c-echo-stderr red b "Foo bar"  # Print red bold message to stderr
c-echo() { __c-echo 1 "$@"; }
c-echo-stderr() { __c-echo 2 "$@"; }
__c-echo() {
  fd=$1
  c_args=(${@:2:$#-2})
  msg=${@:$#}
  [[ -t "$fd" ]] && msg=$(c "${c_args[@]}")$msg$(c)
  if [[ "$fd" -eq 1 ]]; then echo "$msg"
  elif [[ "$fd" -eq 2 ]]; then echo "$msg" >/dev/stderr
  else return 1; fi
}

# Transform a string of text to a kebab case identifier, which means:
#   - All characters are transformed to lower-case
#   - Punctuation characters are deleted
#   - Whitespace characters are replaced by dashes 
#   - Repeated dashes are squeezed to a single dash
#   - Dashes at the beginning or end of the resulting identifier are deleted
str2kebab() {
  tr '[:upper:]' '[:lower:]' | \
  sed 's/[[:punct:]]//g;s/[[:space:]]/-/g' | \
  tr -s - | \
  sed 's/^-//;s/-$//'
}

alias br='vim ~/.bashrc'
alias bp='vim ~/.bash_profile'
alias sbr='. ~/.bashrc'
alias sbp='. ~/.bash_profile'
alias vr='vim ~/.vimrc'
alias rmf='rm -rf'
alias la="ls -a"
alias ll="ls -al"
alias ld="ls -d */"
alias wl='wc -l'
alias dotfiles='git --git-dir=$HOME/.dotfiles --work-tree=$HOME'
alias d=dotfiles
alias ds='dotfiles status'
alias da='dotfiles add'
alias dco='dotfiles commit'
alias dp='dotfiles push'
alias ddi='dotfiles diff'
complete -F _complete_alias dotfiles
complete -F _complete_alias d
alias ssh='TERM=xterm-256color ssh'
alias torsocks='TERM=xterm-256color torsocks'
alias pgrep='pgrep -fl'
alias x='chmod +x'
alias X='chmod -x'
alias which='which -a'
alias watch='watch -n 1'
alias di='date -Iseconds'

# File sizes
alias dh='du -h'
# alias ds='du | sort -k 1 -n -r'
alias dhm='du -h | grep M$"\t" | sort -k 1 -n -r'

# Print or remove completion specification of a command
alias comp='complete -p'
alias compr='complete -r'
complete -c comp compr

# Set default options
alias curl='curl -s'
alias sed='sed -E'
alias gsed='gsed -E'


# Coloured diff output (requires diffutils [1] package)
# [1] https://www.gnu.org/software/diffutils/
alias diff='diff --color'

# Print large directories in the current directory. The threshold for printing
# directories can be specified either as 'g' or 'm':
#   - 'g': print directories larger than 1 GB
#   - 'm': print directories larger than 1 MB
large-dirs() {
  threshold=${1:-g}
  case "$threshold" in
    g) pattern="G$(printf "\t")" ;;
    m) pattern="M$(printf "\t")\|G$(printf "\t")" ;;
  esac
  sudo du -h | grep "$pattern"
}

# Get public IP address of local machine
myip() {
  curl -s checkip.amazonaws.com
}

# Show local ports that are currently in use
ports() {
  lsof -i -P -n | grep LISTEN
}

# Show the help page of a shell builtin like man page
#help() { builtin help -m "$1" | less; }
#complete -b help 

# Show the source file and line where a function is defined
funcfile() {
  shopt -s extdebug
  declare -F "$1"
  shopt -u extdebug
}
complete -A function funcfile

# Search through the central history file (see PROMPT_COMMAND) and either
# print or directly execute the selected command
# TODO: add option for just pasting the selected command to the prompt without
# executing it
hist() {
  ensure fzf
  # Directly execute the command
  if [[ "$1" = -x ]]; then
    eval $(cat "$HISTFILE" | fzf -e --tac)
  # Print the command to stdout
  else
    cat "$HISTFILE" | fzf -e --tac
  fi
}


# Change into the directory of the file pointed to by a symlink
cdl() {
  local t=$(readlink "$1")
  cd $([[ -f "$t" ]] && echo $(dirname "$t") || echo "$t")
}
complete -f cdl

# Change <n> levels up in the directory hierarchy
cdu() {
  local n=${1:-1}
  for i in $(seq 1 "$n"); do
    cd ..
  done
}

# Create new directory and cd to it
mkcd() { mkdir "$1" && cd "$1"; }

# Move file by creating any intemediate dirs of the target, if they don't exist
mvp() { mkdir -p "$2" && mv "$1" "$2"; }

# Recursively list all the files in the specified directory.
listf() { local d=${1:-.}; find "${d%/}" -type f; }

# Recursively count the number of files in the specified directory.
countf () { listf "$1" | wc -l; }

# List all the dotfiles or dot-directories in the specified directory.
dotf() { local d=${1:-.}; __dotx "${d%/}" f; }
dotd() { local d=${1:-.}; __dotx "${d%/}" d; }
__dotx() { find "$1" -name '.*' -maxdepth 1 -type "$2" | xargs -Ix basename x; }

# Change the extension of a filename
chext() { echo "${1%.*}.$2"; }

# Dump the hexadecimal code of the provided string (output depends on the char
# encoding used by the terminal).
enc() { echo -n "$@" | hexdump | head -1 | cut -d ' ' -f 2-; }

# Print the character encoding used by the terminal
enc-type() { echo $LC_CTYPE; }


# Copy to system clipboard
# Usage:
#   clip [file]
# If a file is provided, its content is copied to the clipboard. If no file is
# provided, then stdin is copied to the clipboard.
clip() {
  local cmd
  is-mac && cmd=pbcopy
  is-linux && cmd=xclip
  is-wsl && cmd=clip.exe
  if [[ "$#" -eq 0 ]]; then
    eval "$cmd"
  else
    cat "$1" | eval "$cmd"
  fi
}


#------------------------------------------------------------------------------#
# Numbers
#------------------------------------------------------------------------------#

log2()  { bc -l <<<"l($1) / l(2)" ; }
log10() { bc -l <<<"l($1) / l(10)"; }

# Round number ($1) to specific number of digits ($2) after decimal point
round() { printf "%.$2f\n" "$1"; }

# Round number down to nearest integer
floor() { bc <<<"$1/1"; }

# Test if number is even or odd
even() { (($1 % 2 == 0)); }
odd()  { (($1 % 2 != 0)); }

# Convert numbers between numeral systems. Input read from stdin or arg list.
d2b() { __x2x 10  2 0    "$@"; }
d2o() { __x2x 10  8 0    "$@"; }
d2h() { __x2x 10 16 0    "$@"; }
b2d() { __x2x  2 10 0    "$@"; }
o2d() { __x2x  8 10 0    "$@"; }
h2d() { __x2x 16 10 0    "$@"; }
h2b() { __x2x 16  2 4    "$@"; }
h2o() { __x2x 16  8 0    "$@"; }
b2h() { __x2x  2 16 0.25 "$@"; }
o2h() { __x2x  8 16 0    "$@"; }
b2o() { __x2x  2  8 0.33 "$@"; }
o2b() { __x2x  8  2 3    "$@"; }
# Read input from stdin or arg list
__x2x() {
  (($# == 3)) && ____x2x "$@" $(</dev/stdin) || ____x2x "$@"
}
# Convert numbers and zero-pad based on number of digits and value of arg 3
____x2x() {
  local tok
  for tok in $(to-upper ${@:4}); do
    bc <<< "obase=$2; ibase=$1; $tok" | pad $(bc <<<"(${#tok}*$3)/1")
  done
}

# Print a number in binary, octal, decimal, and hexadecmial formats. The number
# can be provided as binary (0b...), octal (0...), decimal, or hexadecimal (0x...)
n() {
  local PAT_BIN='^0b([01]+)$'
  local PAT_OCT='^0([0-7]+)$'
  local PAT_DEC='^([1-9][0-9]*)$'
  local PAT_HEX='^0x([0-9a-fA-F]+)$'
  local PAT_0='^(0)$'
  local n
  # Convert number to decimal as an intermediary format
  if   [[ $1 =~ $PAT_HEX ]]; then n=$(h2d ${BASH_REMATCH[1]})
  elif [[ $1 =~ $PAT_BIN ]]; then n=$(b2d ${BASH_REMATCH[1]})
  elif [[ $1 =~ $PAT_OCT ]]; then n=$(o2d ${BASH_REMATCH[1]})
  elif [[ $1 =~ $PAT_DEC || $1 =~ $PAT_0 ]]; then n=${BASH_REMATCH[1]}
  else
    echo "Invalid number: $1" && return 1
  fi
  # Convert from decimal to other systems
  echo "Binary: $(d2b $n)"
  echo "Octal: $(d2o $n)"
  echo "Decimal: $n"
  echo "Hexadecimal: $(d2h $n)"
}

# Generate a random hexadecimal string of a given length
hex(){
  digits=$1
  cat /dev/urandom | head -c $((("$digits"/2)+1)) | hexdump -e '"%x"' | head -c "$digits"
  echo
}

# Convert a number of seconds to a "<X>m <Y>s" representation.
sec2min() {
  echo "$(("$1"/60))m $(("$1"%60))s"
}


#------------------------------------------------------------------------------#
# macOS and Linux specific functions
#------------------------------------------------------------------------------#
if is-mac; then

  # Recursively delete all .DS_Store files in the current directory
  alias rmds='find . -type f \( -name .DS_Store -or -name ._.DS_Store \) -delete'

  # Move one or more files or directories to the trash
  trash() {
    for i in "$@"; do
      # mv fails if target directory already exists
      if ! mv "$i" ~/.Trash &>/dev/null; then
        rm -rf ~/.Trash/"$i"
        mv "$i" ~/.Trash
      fi
    done
  }

  # Make Finder hiding hidden files, e.g. dotfiles (default)
  finder_hide() {
    defaults write com.apple.finder AppleShowAllFiles FALSE
    killall Finder
  }

  # Make Finder displaying hidden files
  finder_show() {
    defaults write com.apple.finder AppleShowAllFiles TRUE
    killall Finder
  }

  # Permanently disable the Mac startup sound
  disable_startup_sound() {
    sudo nvram SystemAudioVolume=%80  # %80 = 0x80 (hex) = 128 (dec)
  }

  # Permanently re-enable the Mac startup sound
  enable_startup_sound() {
    sudo nvram -d SystemAudioVolume
  }

  # Get the bundle ID (e.g. com.apple.Preview) of an application
  app-id() {
    local app_name=$1
    osascript -e "id of app \"$app_name\""
  }

  # Convert a date string in a specific format to a UNIX timestamp in seconds.
  # If the date string doesn't include a time, the current time is assumed.
  #   Usage:   date2ts <date> <date_format>
  #   Example: date2ts "2016-02-02 13:21:45" "%Y-%m-%d %H:%M:%S"
  date2ts() {
    date -j -f "$2" "$1" '+%s'
    # Note: -j: disable setting of system date, -f: format of input date
  }

  # Convert a UNIX timestamp in seconds to a date string. The format of the
  # output date string can be optinally specified (e.g. '+%Y-%m-%d %H:%M:%S').
  #   Usage: ts2date <timestamp> [<out_format>]
  ts2date() {
    if is_set "$2"; then date -r "$1" "$2"
    else                 date -r "$1"
    fi
  }

  # Remove application support files after uninstalling Docker Desktop on macOS
  post-uninstall-docker-desktop() {
    sudo rm -rf /usr/local/lib/docker/
    # This is usually the only large directory
    rm -rf ~/Library/Containers/com.docker.docker
    rm -rf ~/.docker/
    rm -rf ~/Library/Application\ Support/Docker\ Desktop
    rm -rf ~/Library/Saved\ Application\ State/com.electron.docker*
    rm -rf ~/Library/Preferences/com.electron.docker*
    rm -rf ~/Library/Group\ Containers/group.com.docker
    rm -rf ~/Library/Logs/Docker\ Desktop
  }

  make-space() {
    sudo rm -rf ./Library/Caches
  }


elif is-linux; then

  alias ls='ls --color=auto'
  alias grep='grep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias egrep='egrep --color=auto'

  # Customise keyboard layout with setxkbmap:
  #   - Add Swiss German keyboard layout
  #   - Swap Caps-Lock and Ctrl keys
  #   - Set key combination for toggling between keyboard layouts
  # All the options and keyboard layouts of setxkbmap can be found in the file
  # ==> /usr/share/X11/xkb/rules/base.lst
  # Notes:
  # - The settings made by setxkbmap do NOT persists across logins
  # - To make the settigns persistent, one option would be to put the setxkbmap
  #   commands directly into ~/.bashrc. However, this may cause an X error
  #   (cannot open display "default display")
  # - Another option would be to put the setxkbmap commands into ~/.xinitrc or
  #   /etc/X11/xorg.conf.d/00-keyboard.conf (different syntax). However, there
  #   are inconsistencies across systems, and different desktop environments
  #   read these files in different ways
  # - Because of the above problems, the setxkbmap commands are provided here
  #   as a function that can be called manually
  # Source: https://wiki.archlinux.org/index.php/Keyboard_configuration_in_Xorg
  #         http://betabug.ch/blogs/ch-athens/1242
  config_keyboard() {
    if $(which setxkbmap); then
      # Set Swiss German and German as keyboard layouts (ch(de) is default)
      setxkbmap 'ch(de),de'
      # Left Alt-Shift for toggling between keyboard layouts
      setxkbmap -option grp:lalt_lshift_toggle
      # Swap Caps-Lock and Ctrl keys
      setxkbmap -option ctrl:swapcaps
    else
      echo "Error: setxkbmap is not installed."
    fi
  }

  # Convert a date string to a UNIX timestamp in seconds. The date string format
  # is the one described in the 'date' man page as '--date=STRING'.
  #   Usage: date2ts <date>
  date2ts() {
    date -d "$1" '+%s'
  }

  # Convert a UNIX timestamp in seconds to a date string. The format of the
  # output date string can be optionally specified (e.g. '+%Y-%m-%d %H:%M:%S').
  #   Usage: ts2date <timestamp> [<out_format>]
  ts2date() {
    if is_set "$2"; then date -d "@$1" "$2"
    else                 date -d "@$1"
    fi
  }

  # Check if the dependencies of a Debian package are installed
  checkdep() {
    dep=($(apt-cache depends "$1" | grep Depends: | cut -d : -f 2))
    for d in "${dep[@]}"; do
      echo -n "$d: "
     if dpkg -s "$d" 2>/dev/null | grep -q "Status: .* installed"; then
        echo installed
      else
        echo "NOT INSTALLED"
      fi
    done
  }
fi


change_mac() {
  local mac=$(openssl rand -hex 6 | sed 's/\(..\)/\1:/g;s/.$//')
  sudo ifconfig en0 ether "$mac"
  echo "Changed MAC address of en0 device to $mac"
}
